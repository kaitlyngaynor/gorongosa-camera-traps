---
title: "RAI_analysis"
author: "Kaitlyn Gaynor"
date: "11/16/2018"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: cosmo
editor_options:
  chunk_output_type: console
---

## Background

This RMarkdown file includes all analysis of the Relative Activity Index from the Gorongosa camera trap data. The RAI data files are created using the RAI_calculation.R script, which turns a raw 15-minute record table into RAI values for each species at each camera based on defined start and end dates. RAI is calculated by dividing the total number of independent species records (independent records are defined as >15 min from any other record of that species) by the number of days for which the camera trap was operating. (RAI = detections / trap-night)

#### Defining seasons
Based on rainfall data from Chitengo (provided by M. Stalmans), I defined the dry season as 7/1/16 - 9/30/16 (3 months: July, August, September). I defined the wet season in two ways: 1/1/17 - 3/31/17 (3 months: January, February, March), and 12/1/16 - 3/31/17 (4 months: December, January, February, March). In the code below, I define RAI as "NA" for all cameras that operated for <=10 days in a given season. I generally ended up using the 4-month wet season, because so many cameras were inoperable in the later months of the wet season. The differences in the length of the seasons shouldn't matter too much for RAI calculation, since RAI is defined as detections per trap night.

## Getting set-up for analysis

```{r setup, message=F, echo=F}
library(gtools)
library(plyr)
library(tidyverse)
library(ggplot2)
library(glmulti)
library(plotrix) # for SE function
library(broom)
library(purrr)
library(rgdal) # for loading shape file
library(gganimate) # for animated plots
library(rmdformats) # for r markdown style
library(RColorBrewer)
library(raster)
library(dplyr)
library(nlme)
library(MuMIn)
library(here)


knitr::opts_knit$set(root.dir = here::here())

# define function for standardizing (convert to Z-score)
zstd <- function (x)  (x-mean(x,na.rm = T))/sd(x,na.rm = T)  

```

Import RAI data files (generated by RAI_calculation.R), then tidy data into long format - where I add a column for season, and then combine all of the rows from all three seasonal data frames together.
```{r import and tidy long}
# import files
rai.dry.year1 <- read.csv("results/RAI/RAI_dry_year1.csv")
rai.wet.year1 <- read.csv("results/RAI/RAI_wet4mo_year1.csv")
rai.dry.year2 <- read.csv("results/RAI/RAI_dry_year2.csv")
rai.wet.year2 <- read.csv("results/RAI/RAI_wet4mo_year2.csv")

# duplicate seasonal files for tidying
rai.dry.year1.2 <- rai.dry.year1
rai.wet.year1.2 <- rai.wet.year1
rai.dry.year2.2 <- rai.dry.year2
rai.wet.year2.2 <- rai.wet.year2

# add column for season
rai.dry.year1.2$Season <- "dry"
rai.wet.year1.2$Season <- "wet"
rai.dry.year2.2$Season <- "dry"
rai.wet.year2.2$Season <- "wet"

# add column for year
rai.dry.year1.2$Year <- "1"
rai.wet.year1.2$Year <- "1"
rai.dry.year2.2$Year <- "2"
rai.wet.year2.2$Year <- "2"

# combine into one long dataframe
rai.long <- rbind(rai.dry.year1.2, rai.wet.year1.2, rai.dry.year2.2, rai.wet.year2.2)
rai.long.dry <- rbind(rai.dry.year1.2, rai.dry.year2.2)
rai.long.wet <- rbind(rai.wet.year1.2, rai.wet.year2.2)

# for cameras that were operating <10 days, change Count and RAI to NA
# (actually not necessary anymore; I think I did this in the code used to generate the above files)
# actually IS necessary because there are a few where there are 1 record but 0 operation days, so RAI is infinity!
for (i in 1:nrow(rai.long)) {
  if(rai.long$Operation[i] < 10) {
    rai.long$Count[i] <- NA
    rai.long$RAI[i] <- NA
  } 
}
for (i in 1:nrow(rai.long.dry)) {
  if(rai.long.dry$Operation[i] < 10) {
    rai.long.dry$Count[i] <- NA
    rai.long.dry$RAI[i] <- NA
  } 
}
for (i in 1:nrow(rai.long.wet)) {
  if(rai.long.wet$Operation[i] < 10) {
    rai.long.wet$Count[i] <- NA
    rai.long.wet$RAI[i] <- NA
  } 
}
```

Alternatively, for other analyses, tidy data into wide format - with one row per species-camera pair, and a separate column for Operation, Count, and RAI at each time period.
```{r tidy wide, message = F}
# exclude wet month cameras where operation was <= 10 days (RAI will appear as NA later when merged)
rai.dry.year1 <- rai.dry.year1[rai.dry.year1$Operation >= 10,]
rai.wet.year1 <- rai.wet.year1[rai.wet.year1$Operation >= 10,]
rai.dry.year2 <- rai.dry.year2[rai.dry.year2$Operation >= 10,]
rai.wet.year2 <- rai.wet.year2[rai.wet.year2$Operation >= 10,]

# rename count and RAI columns so they are distinct
names(rai.dry.year1) <- c("StudySite", "Operation.dry.year1", "CommName", "Count.dry.year1", "RAI.dry.year1")
names(rai.wet.year1) <- c("StudySite", "Operation.wet.year1", "CommName", "Count.wet.year1", "RAI.wet.year1")
names(rai.dry.year2) <- c("StudySite", "Operation.dry.year2", "CommName", "Count.dry.year2", "RAI.dry.year2")
names(rai.wet.year2) <- c("StudySite", "Operation.wet.year2", "CommName", "Count.wet.year2", "RAI.wet.year2")

# join into single dataframe
rai.year1 <- join(rai.dry.year1, rai.wet.year1)
rai.year2 <- join(rai.dry.year2, rai.wet.year2)
rai <- join(rai.year1, rai.year2)
```

Import camera covariates, standardize for analysis, and merge with RAI.
Note that on 12/12/18, I standardized all of the spatial variables FIRST (before extracting), so this only needs to be done for the variables collected at the camera site
```{r cam covariates, message = F}
# import spreadsheet with camera covariates (all are already standardized)
covariates <- read.csv("data/cam_metadata_norm_031519.csv")

# merge with RAI
rai <- join(rai, covariates)

# also merge with RAI long
rai.long <- join(rai.long, covariates)
```

Import species covariates, and merge with RAI/camera covariates.
```{r spp covariates, message = F}
# import species covariates and merge in
species <- read.csv("data/2018spp_kingdon.csv")
rai <- join(rai, species)

# also join with long
rai.long <- join(rai.long, species)
```

Calculate mean, SD, and standard error of RAI for each species (across cameras), with one row per species, and join camera covariates.
```{r species RAI, message = F}
species.rai <- rai %>%
  dplyr::group_by(CommName) %>%
  dplyr::summarise(RAI.dry.year1.mean = mean(RAI.dry.year1, na.rm=T), 
                   RAI.dry.year1.sd = sd(RAI.dry.year1, na.rm=T),
                   RAI.dry.year1.se = std.error(RAI.dry.year1, na.rm=T),
                   RAI.wet.year1.mean = mean(RAI.wet.year1, na.rm=T), 
                   RAI.wet.year1.sd = sd(RAI.wet.year1, na.rm=T),
                   RAI.wet.year1.se = std.error(RAI.wet.year1, na.rm=T),
                   RAI.dry.year2.mean = mean(RAI.dry.year2, na.rm=T), 
                   RAI.dry.year2.sd = sd(RAI.dry.year2, na.rm=T),
                   RAI.dry.year2.se = std.error(RAI.dry.year2, na.rm=T),
                   RAI.wet.year2.mean = mean(RAI.wet.year2, na.rm=T), 
                   RAI.wet.year2.sd = sd(RAI.wet.year2, na.rm=T),
                   RAI.wet.year2.se = std.error(RAI.wet.year2, na.rm=T)
                   ) 

# join species covariates with that new table
species.rai <- join(species.rai, species)

# do a long version - note that for species-camera pairs where there were no detections, the row is missing (rather than NA)
species.rai.long.allseasons <- rai.long %>%
  dplyr::group_by(CommName, Season, Year) %>%
  dplyr::summarise(RAI.mean = mean(RAI, na.rm=T), 
                   RAI.sd = sd(RAI, na.rm=T), 
                   RAI.se = std.error(RAI, na.rm=T))

# join species covariates with that new table. For some reason, 'join' doesn't work since there are multiple rows with the same species, but 'merge' works well
species.rai.long <- merge(species.rai.long.allseasons, species)

species.rai.long.lmh <- species.rai.long[species.rai.long$LMH == "yes",]

```

## Calculate correlations in RAI between pairs of LMH species.

```{r calculate RAI correlations}
# subset RAI to only LMH, format appropriately
rai.lmh <- rai[rai$LMH == "yes",]
rai.lmh.dry.year1 <- dplyr::select(rai.lmh, StudySite, SppCode, RAI.dry.year1)
rai.lmh.wet.year1 <- dplyr::select(rai.lmh, StudySite, SppCode, RAI.wet.year1)
rai.lmh.dry.year2 <- dplyr::select(rai.lmh, StudySite, SppCode, RAI.dry.year2)
rai.lmh.wet.year2 <- dplyr::select(rai.lmh, StudySite, SppCode, RAI.wet.year2)
names(rai.lmh.dry.year1) <- c("StudySite", "SppCode", "RAI")
names(rai.lmh.wet.year1) <- c("StudySite", "SppCode", "RAI")
names(rai.lmh.dry.year2) <- c("StudySite", "SppCode", "RAI")
names(rai.lmh.wet.year2) <- c("StudySite", "SppCode", "RAI")

rai.lmh.dry.year1 <- spread(rai.lmh.dry.year1, key = "SppCode", value = "RAI")
rai.lmh.wet.year1 <- spread(rai.lmh.wet.year1, key = "SppCode", value = "RAI")
rai.lmh.dry.year2 <- spread(rai.lmh.dry.year2, key = "SppCode", value = "RAI")
rai.lmh.wet.year2 <- spread(rai.lmh.wet.year2, key = "SppCode", value = "RAI")

# combined years 1 and 2
rai.lmh.dry.year1and2 <- rbind(rai.lmh.dry.year1, rai.lmh.dry.year2)
rai.lmh.wet.year1and2 <- rbind(rai.lmh.wet.year1, rai.lmh.wet.year2)


# bring in list of all pairwise relationships (generated previously for SIF models)
pairs <- read.csv("data/SIF/fewer_cameras/Dry.peak.SppPairs.csv")

# subset to only LMH species (couldn't figure out a more elegant way to do this)
pairs <- subset(pairs, SppCode1 == "AEME" | SppCode1 == "ALBU" | SppCode1 == "CENA" | SppCode1 == "COTA" | SppCode1 == "HIAM"
                | SppCode1 == "HINI" | SppCode1 == "LOAF" | SppCode1 == "KOEL" | SppCode1 == "OUOU" | SppCode1 == "PHAF" | SppCode1 == "POLA"
                | SppCode1 == "RERE" | SppCode1 == "SYGR" | SppCode1 == "SYCA" | SppCode1 == "TAOR" | SppCode1 == "TRAN"
                | SppCode1 == "TRST" | SppCode1 == "TRSY")
pairs <- subset(pairs, SppCode2 == "AEME" | SppCode2 == "ALBU" | SppCode2 == "CENA" | SppCode2 == "COTA" | SppCode2 == "HIAM"
                | SppCode2 == "HINI" | SppCode2 == "KOEL" | SppCode2 == "LOAF" | SppCode2 == "OUOU" | SppCode2 == "PHAF" | SppCode2 == "POLA"
                | SppCode2 == "RERE" | SppCode2 == "SYGR" | SppCode2 == "SYCA" | SppCode2 == "TAOR" | SppCode2 == "TRAN"
                | SppCode2 == "TRST" | SppCode2 == "TRSY")

# edit so there is just one row per pairwise relationship, and columns for the two species
pairs <- pairs[pairs$StudySite == "A06", 2:3]

# create new column for temporal overlap
pairs$RAI.correlation.dry.year1 <- NA
pairs$RAI.correlation.wet.year1 <- NA
pairs$RAI.correlation.dry.year2 <- NA
pairs$RAI.correlation.wet.year2 <- NA
pairs$RAI.correlation.dry.year1and2 <- NA
pairs$RAI.correlation.wet.year1and2 <- NA


# calculate seasonal temporal overlap for each pairwise interaction
for (i in 1:nrow(pairs)) {
  
  species1 <- as.character(pairs[i,1]) # get SppCode1 value
  species2 <- as.character(pairs[i,2]) # get SppCode2 value
  
  if (species1 == "HIAM") {pairs[i,3] <- NA} else if (species2 == "HIAM") {pairs[i,3] <- NA} else {comparison <- dplyr::select(rai.lmh.dry.year1, species1, species2)
  pairs[i,3] <- cor(comparison[,1], comparison[,2], use = "complete.obs") }

  comparison <- dplyr::select(rai.lmh.wet.year1, species1, species2)
  pairs[i,4] <- cor(comparison[,1], comparison[,2], use = "complete.obs")

  if (species1 == "HIAM") {pairs[i,5] <- NA} else if (species2 == "HIAM") {pairs[i,5] <- NA} else {comparison <- dplyr::select(rai.lmh.dry.year2, species1, species2)
  pairs[i,5] <- cor(comparison[,1], comparison[,2], use = "complete.obs") }

  comparison <- dplyr::select(rai.lmh.wet.year2, species1, species2)
  pairs[i,6] <- cor(comparison[,1], comparison[,2], use = "complete.obs")

  if (species1 == "HIAM") {pairs[i,7] <- NA} else if (species2 == "HIAM") {pairs[i,7] <- NA} else {comparison <- dplyr::select(rai.lmh.dry.year1and2, species1, species2)
  pairs[i,7] <- cor(comparison[,1], comparison[,2], use = "complete.obs") }

  comparison <- dplyr::select(rai.lmh.wet.year1and2, species1, species2)
  pairs[i,8] <- cor(comparison[,1], comparison[,2], use = "complete.obs")

}

# export overlap
write.csv(pairs, "results/Overlap_RAI_031919.csv", row.names=F)

```

I did another version where I standardized the RAI values first BUT it had absolutely no effect on the correlation coefficients. Apparently I forget how correlation coefficients are calculated.

## General patterns in RAI between dry and wet seasons

Each point represents one species, so you can easily see differences in RAI across species. They are colored according to their diet category (carnivore, omnivore, herbivore). The point represents the mean RAI across the n=60 cameras (n=55 for wet season). Error bars correspond to the standard error of the mean.

The diagonal line represents RAI.dry = RAI.wet (same activity in wet and dry season). Points above the line represent species more active in the wet season, and below the line are more active in the dry season (I tried to shade these areas differently using geom_ribbon but couldn't figure it out, so abandoned the effort). 

Summarize long data first
```{r fix up long data}
species.rai2 <- rai.long %>%
  dplyr::group_by(CommName, Season) %>%
  dplyr::summarise(RAI.mean = mean(RAI, na.rm=T), 
                   RAI.sd = sd(RAI, na.rm=T),
                   RAI.se = std.error(RAI, na.rm=T))

species.rai2 <- merge(species.rai2, species)




# still can't figure out how to do a spread with multiple values

rai.avg.dry <- rai.long.dry %>%
  dplyr::group_by(CommName) %>%
  dplyr::summarise(RAI.dry.mean = mean(RAI, na.rm=T), 
                   RAI.dry.sd = sd(RAI, na.rm=T),
                   RAI.dry.se = std.error(RAI, na.rm=T))
rai.avg.wet <- rai.long.wet %>%
  dplyr::group_by(CommName) %>%
  dplyr::summarise(RAI.wet.mean = mean(RAI, na.rm=T), 
                   RAI.wet.sd = sd(RAI, na.rm=T),
                   RAI.wet.se = std.error(RAI, na.rm=T))
rai.avg.wide <- left_join(rai.avg.wet, rai.avg.dry)
rai.avg.wide <- join(rai.avg.wide, species)
```

Plot relative change in RAI between seasons.
```{r wet divided by dry}
rai.avg.wide$RAI.ratio <- log(rai.avg.wide$RAI.wet.mean / rai.avg.wide$RAI.dry.mean)

plot(RAI.ratio ~ Floodplain.pct, data = subset(rai.avg.wide, CommName != 'Duiker_common'))
abline(h=0)
```




Plots like the occupancy ones.

```{r plots like the occupancy ones}
species.rai2$CommName_Full <- reorder(species.rai2$CommName_Full, species.rai2$RAI.mean)
rai.avg.wide$CommName_Full <- reorder(rai.avg.wide$CommName_Full, rai.avg.wide$RAI.dry.mean)

## with 95% CI
#pdf('Figures/RAI/RAIlog.byseason.allspecies.pdf', width = 9, height = 5)
ggplot(species.rai2, aes(x=CommName_Full, y=log(RAI.mean), col = Season)) + 
  geom_errorbar(aes(ymin = log(RAI.mean - RAI.se), ymax = log(RAI.mean + RAI.se)), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  labs(title = "Seasonal RAI (log scale)") +
  ylab("log Relative Activity Index") +
  xlab("Species") +
  facet_grid(~ Diet, scales = 'free', space = "free_x") 
#dev.off()

#pdf('Figures/RAI/RAI.byseason.allspecies.pdf', width = 9, height = 5)
ggplot(species.rai2, aes(x=CommName_Full, y=(RAI.mean), col = Season)) + 
  geom_errorbar(aes(ymin = RAI.mean - RAI.se, ymax = RAI.mean + RAI.se), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  labs(title = "Seasonal RAI") +
  ylab("Relative Activity Index") +
  xlab("Species") +
  facet_grid(~ Diet, scales = 'free', space = "free_x") 
#dev.off()

## with SE bars - LMH only
#pdf('Figures/RAI/RAIlog.byseason.lmh.pdf', width = 7, height = 5, useDingbats = F)
ggplot(subset(species.rai2, LMH == "yes"), aes(x=CommName_Full, y=log(RAI.mean), col = Season)) + 
  geom_errorbar(aes(ymin = log(RAI.mean - RAI.se), ymax = log(RAI.mean + RAI.se)), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
#  labs(title = "Seasonal RAI (log scale)") +
    ylab("log Relative Activity Index") +
  xlab("Species")
#dev.off()

#pdf('Figures/RAI/RAI.byseason.lmh.pdf', width = 7, height = 5, useDingbats = F)
ggplot(subset(species.rai2, LMH == "yes"), aes(x=CommName_Full, y=(RAI.mean), col = Season)) + 
  geom_errorbar(aes(ymin = RAI.mean - RAI.se, ymax = RAI.mean + RAI.se), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
#  labs(title = "Seasonal RAI") +
    ylab("Relative Activity Index") +
  xlab("Species")
dev.off()

# wrap by season
ggplot(subset(species.rai2, LMH == "yes"), aes(x=CommName_Full, y=RAI.mean)) + 
  geom_errorbar(aes(ymin = RAI.mean - RAI.se, ymax = RAI.mean + RAI.se), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  facet_wrap(~ Season) +
  labs(title = "Seasonal Occupancy") 

# wrap by water dependence
pdf('Figures/RAI/RAI.byseason.lmh.waterdependence.pdf', width = 8, height = 5)
ggplot(subset(species.rai2, LMH == "yes"), aes(x=CommName_Full, y=RAI.mean, col = Season)) + 
  geom_errorbar(aes(ymin = RAI.mean - RAI.se, ymax = RAI.mean + RAI.se), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  facet_grid(~ Hempsen_water_dependence, scales='free_x', space = "free_x") +
  labs(title = "Seasonal RAI by Water Dependence") +
  ylab("Relative Activity Index") +
  xlab("Species")
#dev.off()

# wrap by water dependence - log
#pdf('Figures/RAI/RAIlog.byseason.lmh.waterdependence.pdf', width = 8, height = 5)
ggplot(subset(species.rai2, LMH == "yes"), aes(x=CommName_Full, y=log(RAI.mean), col = Season)) + 
  geom_errorbar(aes(ymin = log(RAI.mean - RAI.se), ymax = log(RAI.mean + RAI.se)), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  facet_grid(~ Hempsen_water_dependence, scales='free_x', space = "free_x") +
  labs(title = "Seasonal RAI by Water Dependence (log scale)") +
  ylab("log Relative Activity Index") +
  xlab("Species")
#dev.off()

# plot means vs floodplain biomass
#pdf('Figures/RAI/RAIlog.by.floodplain.pdf', width = 8, height = 5)
ggplot(subset(species.rai2, LMH == "yes"), aes(x=Floodplain.pct, y=log(RAI.mean), col = Season, fill = Season)) + 
  geom_point() +
  geom_smooth(method='lm') +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  labs(title = "RAI by Floodplain Preference") +
  facet_wrap(~Season) + 
  theme(legend.title = element_blank()) +
  ylab("log Relative Activity Index") +
  xlab("Percentage of Biomass on Floodplain in Dry Season")
#dev.off()

# subtract matrix of camera x species wet and dry
# put in as placeholder
rai.lmh.bothseasons.year1and2 <- rai.lmh.dry.year1and2
for (i in 1:nrow(rai.lmh.dry.year1and2)){
  for (j in 2:ncol(rai.lmh.dry.year1and2)) {
    rai.lmh.bothseasons.year1and2[i,j] <- rai.lmh.wet.year1and2[i,j] - rai.lmh.dry.year1and2[i,j]
  }
}

# not working anymore, unsure why... to troubleshoot
rai.lmh.bothseasons.year1and2.summary <- rai.lmh.bothseasons.year1and2 %>% 
  gather('AEME', 'ALBU', 'CENA', 'COTA', 'HIAM', 'HINI', 'KOEL', 'LOAF', 'OUOU', 'PHAF', 'POLA', 'RERE', 'SYCA', 'SYGR', 'TAOR', 'TRAN', 'TRST', 'TRSY', key = 'SppCode', value = "RAI.difference") %>%
  group_by(SppCode) %>%
  summarise(RAI.difference.mean = mean(RAI.difference, na.rm = T)) %>%
  left_join(species)



# plot RAI difference vs floodplain biomass
#pdf('Figures/RAI/RAIdifference.by.floodplain.pdf', width = 8, height = 5)
ggplot(rai.lmh.bothseasons.year1and2.summary, aes(x=Floodplain.pct, y=RAI.difference.mean)) + 
  geom_point() +
  geom_smooth(method='lm') +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  labs(title = "RAI by Floodplain Preference") +
  theme(legend.title = element_blank()) +
  ylab("Relative Activity Index difference (Wet - Dry)") +
  xlab("Percentage of Biomass on Floodplain in Dry Season")
#dev.off()
```



```{r dry vs wet species averages, message = F}
# combined years 1 and 2 - boxplots for each species (impossible to understand)
ggplot(rai.long, aes(x = Season, y = RAI)) + 
  geom_boxplot() +
  facet_wrap(~CommName, scales = 'free')




# plot dry vs wet average, untransformed
# year 1
ggplot(species.rai, aes(x=RAI.dry.year1.mean, y=RAI.wet.year1.mean, colour=Diet)) + 
  geom_abline() +  # adds diagonal line for reference
  geom_point() +
  geom_errorbar(aes(ymin=RAI.wet.year1.mean-RAI.wet.year1.se, ymax=RAI.wet.year1.mean+RAI.wet.year1.se)) +
  geom_errorbarh(aes(xmin=RAI.dry.year1.mean-RAI.dry.year1.se, xmax=RAI.dry.year1.mean+RAI.dry.year1.se)) +
  geom_text(aes(label=CommName),hjust=0, vjust=0)

# year 2
ggplot(species.rai, aes(x=RAI.dry.year2.mean, y=RAI.wet.year2.mean, colour=Diet)) + 
  geom_abline() +  # adds diagonal line for reference
  geom_point() +
  geom_errorbar(aes(ymin=RAI.wet.year2.mean-RAI.wet.year2.se, ymax=RAI.wet.year2.mean+RAI.wet.year2.se)) +
  geom_errorbarh(aes(xmin=RAI.dry.year2.mean-RAI.dry.year2.se, xmax=RAI.dry.year2.mean+RAI.dry.year2.se)) +
  geom_text(aes(label=CommName),hjust=0, vjust=0)

```

**You can see right away that warthog, baboon, waterbuck, and bushbuck have (by far!) the greatest number of detections in both dry and wet seasons. This isn't very surprising.**

This plot below shows the same thing; I log-transformed the RAI values for visualization, because the data was heavily skewed right (many low RAI values). 

```{r dry vs wet species averages transformed, message = F, warning = F}
# plot dry vs wet average, with log transformation - there is a warning message because some of the values are NaN (log of a negative number), so these are just missing error bars in those cases
ggplot(species.rai, aes(x=log(RAI.dry.year1.mean), y=log(RAI.wet.year1.mean), colour=Diet)) + 
  geom_abline() +  # adds diagonal line for reference
  geom_point() +
  geom_text(aes(label=CommName),hjust=0, vjust=0)

# year 2 
ggplot(species.rai, aes(x=log(RAI.dry.year2.mean), y=log(RAI.wet.year2.mean), colour=Diet)) + 
  geom_abline() +  # adds diagonal line for reference
  geom_point() +
  geom_text(aes(label=CommName),hjust=0, vjust=0)
```

**Generally, the carnivore species (in red) and omnivore species (in blue) have more detections in the dry season than the wet season. However, I do not think this is actually due to greater 'relative activity.' I would instead attribute this seasonal pattern to a lower detection rate in thet wet season, when the grass is taller, and these animals may be able to move in front of the cameras (through the grass) without triggering them.**

Compare by year.
```{r compare by year}
# dry season
ggplot(species.rai, aes(x=RAI.dry.year1.mean, y=RAI.dry.year2.mean, colour=Diet)) + 
  geom_abline() +  # adds diagonal line for reference
  geom_point() +
  geom_errorbar(aes(ymin=RAI.dry.year2.mean-RAI.dry.year2.se, ymax=RAI.dry.year2.mean+RAI.dry.year2.se)) +
  geom_errorbarh(aes(xmin=RAI.dry.year1.mean-RAI.dry.year1.se, xmax=RAI.dry.year1.mean+RAI.dry.year1.se)) +
  geom_text(aes(label=CommName),hjust=0, vjust=0)

# wet season
ggplot(species.rai, aes(x=RAI.wet.year1.mean, y=RAI.wet.year2.mean, colour=Diet)) + 
  geom_abline() +  # adds diagonal line for reference
  geom_point() +
  geom_errorbar(aes(ymin=RAI.wet.year2.mean-RAI.wet.year2.se, ymax=RAI.wet.year2.mean+RAI.wet.year2.se)) +
  geom_errorbarh(aes(xmin=RAI.wet.year1.mean-RAI.wet.year1.se, xmax=RAI.wet.year1.mean+RAI.wet.year1.se)) +
  geom_text(aes(label=CommName),hjust=0, vjust=0)

# LOG SCALE
# dry season
ggplot(species.rai, aes(x=log(RAI.dry.year1.mean), y=log(RAI.dry.year2.mean), colour=Diet)) + 
  geom_abline() +  # adds diagonal line for reference
  geom_point() 

# wet season
ggplot(species.rai, aes(x=log(RAI.wet.year1.mean), y=log(RAI.wet.year2.mean), colour=Diet)) + 
  geom_abline() +  # adds diagonal line for reference
  geom_point() 
```


Subset data by species (so each species is in its own dataframe, with 60 rows, one per camera). In retrospect, this could have been done much more cleanly and efficiently. (code not shown)
```{r subset species, echo = F}
rai.aeme <- rai[rai$SppCode == "AEME", ]
rai.albu <- rai[rai$SppCode == "ALBU", ]
rai.atpa <- rai[rai$SppCode == "ATPA", ]
rai.bdcr <- rai[rai$SppCode == "BDCR", ]
rai.ceal <- rai[rai$SppCode == "CEAL", ]
rai.cena <- rai[rai$SppCode == "CENA", ]
rai.chpy <- rai[rai$SppCode == "CHPY", ]
rai.cici <- rai[rai$SppCode == "CICI", ]
rai.cota <- rai[rai$SppCode == "COTA", ]
rai.gasa <- rai[rai$SppCode == "GASA", ]
rai.gege <- rai[rai$SppCode == "GEGE", ]
rai.heic <- rai[rai$SppCode == "HEIC", ]
rai.hepa <- rai[rai$SppCode == "HEPA", ]
rai.hiam <- rai[rai$SppCode == "HIAM", ]
rai.hini <- rai[rai$SppCode == "HINI", ]
rai.hyaf <- rai[rai$SppCode == "HYAF", ]
rai.ical <- rai[rai$SppCode == "ICAL", ]
rai.koel <- rai[rai$SppCode == "KOEL", ]
rai.lemi <- rai[rai$SppCode == "LEMI", ]
rai.lese <- rai[rai$SppCode == "LESE", ]
rai.loaf <- rai[rai$SppCode == "LOAF", ]
rai.mate <- rai[rai$SppCode == "MATE", ]
rai.meca <- rai[rai$SppCode == "MECA", ]
rai.mumu <- rai[rai$SppCode == "MUMU", ]
rai.oraf <- rai[rai$SppCode == "ORAF", ]
rai.otcr <- rai[rai$SppCode == "OTCR", ]
rai.ouou <- rai[rai$SppCode == "OUOU", ]
rai.pacy <- rai[rai$SppCode == "PACY", ]
rai.pale <- rai[rai$SppCode == "PALE", ]
rai.phaf <- rai[rai$SppCode == "PHAF", ]
rai.pola <- rai[rai$SppCode == "POLA", ]
rai.rere <- rai[rai$SppCode == "RERE", ]
rai.syca <- rai[rai$SppCode == "SYCA", ]
rai.sygr <- rai[rai$SppCode == "SYGR", ]
rai.taor <- rai[rai$SppCode == "TAOR", ]
rai.tran <- rai[rai$SppCode == "TRAN", ]
rai.trst <- rai[rai$SppCode == "TRST", ]
rai.trsy <- rai[rai$SppCode == "TRSY", ]

rai.lmh <- rai[rai$LMH == "yes",]
```

Subset LONG data to combine years 1 and 2.
```{r subset long data}
rai.long.dry <- rai.long[rai.long$Season == "dry", ]
rai.long.wet <- rai.long[rai.long$Season == "wet", ]

long.lmh.list.dry <- list()
long.lmh.list.dry[[1]] <- rai.long.dry[rai.long.dry$SppCode == "AEME", ]
long.lmh.list.dry[[2]] <- rai.long.dry[rai.long.dry$SppCode == "ALBU", ]
long.lmh.list.dry[[3]] <- rai.long.dry[rai.long.dry$SppCode == "CENA", ]
long.lmh.list.dry[[4]] <- rai.long.dry[rai.long.dry$SppCode == "COTA", ]
long.lmh.list.dry[[5]] <- rai.long.dry[rai.long.dry$SppCode == "HIAM", ]
long.lmh.list.dry[[6]] <- rai.long.dry[rai.long.dry$SppCode == "HINI", ]
long.lmh.list.dry[[7]] <- rai.long.dry[rai.long.dry$SppCode == "KOEL", ]
long.lmh.list.dry[[8]] <- rai.long.dry[rai.long.dry$SppCode == "LOAF", ]
long.lmh.list.dry[[9]] <- rai.long.dry[rai.long.dry$SppCode == "OUOU", ]
long.lmh.list.dry[[10]] <- rai.long.dry[rai.long.dry$SppCode == "PHAF", ]
long.lmh.list.dry[[11]] <- rai.long.dry[rai.long.dry$SppCode == "POLA", ]
long.lmh.list.dry[[12]] <- rai.long.dry[rai.long.dry$SppCode == "RERE", ]
long.lmh.list.dry[[13]] <- rai.long.dry[rai.long.dry$SppCode == "SYCA", ]
long.lmh.list.dry[[14]] <- rai.long.dry[rai.long.dry$SppCode == "SYGR", ]
long.lmh.list.dry[[15]] <- rai.long.dry[rai.long.dry$SppCode == "TAOR", ]
long.lmh.list.dry[[16]] <- rai.long.dry[rai.long.dry$SppCode == "TRAN", ]
long.lmh.list.dry[[17]] <- rai.long.dry[rai.long.dry$SppCode == "TRST", ]
long.lmh.list.dry[[18]] <- rai.long.dry[rai.long.dry$SppCode == "TRSY", ]

long.lmh.list.wet <- list()
long.lmh.list.wet[[1]] <- rai.long.wet[rai.long.wet$SppCode == "AEME", ]
long.lmh.list.wet[[2]] <- rai.long.wet[rai.long.wet$SppCode == "ALBU", ]
long.lmh.list.wet[[3]] <- rai.long.wet[rai.long.wet$SppCode == "CENA", ]
long.lmh.list.wet[[4]] <- rai.long.wet[rai.long.wet$SppCode == "COTA", ]
long.lmh.list.wet[[5]] <- rai.long.wet[rai.long.wet$SppCode == "HIAM", ]
long.lmh.list.wet[[6]] <- rai.long.wet[rai.long.wet$SppCode == "HINI", ]
long.lmh.list.wet[[7]] <- rai.long.wet[rai.long.wet$SppCode == "KOEL", ]
long.lmh.list.wet[[8]] <- rai.long.wet[rai.long.wet$SppCode == "LOAF", ]
long.lmh.list.wet[[9]] <- rai.long.wet[rai.long.wet$SppCode == "OUOU", ]
long.lmh.list.wet[[10]] <- rai.long.wet[rai.long.wet$SppCode == "PHAF", ]
long.lmh.list.wet[[11]] <- rai.long.wet[rai.long.wet$SppCode == "POLA", ]
long.lmh.list.wet[[12]] <- rai.long.wet[rai.long.wet$SppCode == "RERE", ]
long.lmh.list.wet[[13]] <- rai.long.wet[rai.long.wet$SppCode == "SYCA", ]
long.lmh.list.wet[[14]] <- rai.long.wet[rai.long.wet$SppCode == "SYGR", ]
long.lmh.list.wet[[15]] <- rai.long.wet[rai.long.wet$SppCode == "TAOR", ]
long.lmh.list.wet[[16]] <- rai.long.wet[rai.long.wet$SppCode == "TRAN", ]
long.lmh.list.wet[[17]] <- rai.long.wet[rai.long.wet$SppCode == "TRST", ]
long.lmh.list.wet[[18]] <- rai.long.wet[rai.long.wet$SppCode == "TRSY", ]
```


Is there a statistically significant difference in RAI between seasons? Paired t-test to assess RAI between wet and dry seasons for each species. (code not shown)
```{r t-test, echo = F}
ttests <- list() # create list to store model outputs in

# run each species. there's probably a way to do as a for loop... I couldn't get it to work
ttests[[1]] <- t.test(rai.aeme$RAI.dry.year1, rai.aeme$RAI.wet.year1, paired=T)
ttests[[2]] <- t.test(rai.albu$RAI.dry.year1, rai.albu$RAI.wet.year1, paired=T)
ttests[[3]] <- t.test(rai.atpa$RAI.dry.year1, rai.atpa$RAI.wet.year1, paired=T)
ttests[[4]] <- t.test(rai.bdcr$RAI.dry.year1, rai.bdcr$RAI.wet.year1, paired=T)
ttests[[5]] <- t.test(rai.ceal$RAI.dry.year1, rai.ceal$RAI.wet.year1, paired=T)
ttests[[6]] <- t.test(rai.cena$RAI.dry.year1, rai.cena$RAI.wet.year1, paired=T)
ttests[[7]] <- t.test(rai.chpy$RAI.dry.year1, rai.chpy$RAI.wet.year1, paired=T)
ttests[[8]] <- t.test(rai.cici$RAI.dry.year1, rai.cici$RAI.wet.year1, paired=T)
ttests[[9]] <- t.test(rai.cota$RAI.dry.year1, rai.cota$RAI.wet.year1, paired=T)
ttests[[10]] <- t.test(rai.gasa$RAI.dry.year1, rai.gasa$RAI.wet.year1, paired=T)
ttests[[11]] <- t.test(rai.gege$RAI.dry.year1, rai.gege$RAI.wet.year1, paired=T)
ttests[[12]] <- t.test(rai.heic$RAI.dry.year1, rai.heic$RAI.wet.year1, paired=T)
ttests[[13]] <- t.test(rai.hepa$RAI.dry.year1, rai.hepa$RAI.wet.year1, paired=T)
# ttests[[14]] <- t.test(rai.hiam$RAI.dry.year1, rai.hiam$RAI.wet.year1, paired=T) can't do for hippo, no dry.year1 season
ttests[[15]] <- t.test(rai.hini$RAI.dry.year1, rai.hini$RAI.wet.year1, paired=T)
ttests[[16]] <- t.test(rai.hyaf$RAI.dry.year1, rai.hyaf$RAI.wet.year1, paired=T)
ttests[[17]] <- t.test(rai.ical$RAI.dry.year1, rai.ical$RAI.wet.year1, paired=T)
ttests[[18]] <- t.test(rai.koel$RAI.dry.year1, rai.koel$RAI.wet.year1, paired=T)
ttests[[19]] <- t.test(rai.lemi$RAI.dry.year1, rai.lemi$RAI.wet.year1, paired=T)
ttests[[20]] <- t.test(rai.lese$RAI.dry.year1, rai.lese$RAI.wet.year1, paired=T)
ttests[[21]] <- t.test(rai.loaf$RAI.dry.year1, rai.loaf$RAI.wet.year1, paired=T)
ttests[[22]] <- t.test(rai.mate$RAI.dry.year1, rai.mate$RAI.wet.year1, paired=T)
ttests[[23]] <- t.test(rai.meca$RAI.dry.year1, rai.meca$RAI.wet.year1, paired=T)
ttests[[24]] <- t.test(rai.mumu$RAI.dry.year1, rai.mumu$RAI.wet.year1, paired=T)
ttests[[25]] <- t.test(rai.oraf$RAI.dry.year1, rai.oraf$RAI.wet.year1, paired=T)
ttests[[26]] <- t.test(rai.otcr$RAI.dry.year1, rai.otcr$RAI.wet.year1, paired=T)
ttests[[27]] <- t.test(rai.ouou$RAI.dry.year1, rai.ouou$RAI.wet.year1, paired=T)
ttests[[28]] <- t.test(rai.pacy$RAI.dry.year1, rai.pacy$RAI.wet.year1, paired=T)
ttests[[29]] <- t.test(rai.pale$RAI.dry.year1, rai.pale$RAI.wet.year1, paired=T)
ttests[[30]] <- t.test(rai.phaf$RAI.dry.year1, rai.phaf$RAI.wet.year1, paired=T)
ttests[[31]] <- t.test(rai.pola$RAI.dry.year1, rai.pola$RAI.wet.year1, paired=T)
ttests[[32]] <- t.test(rai.rere$RAI.dry.year1, rai.rere$RAI.wet.year1, paired=T)
ttests[[33]] <- t.test(rai.syca$RAI.dry.year1, rai.syca$RAI.wet.year1, paired=T)
ttests[[34]] <- t.test(rai.sygr$RAI.dry.year1, rai.sygr$RAI.wet.year1, paired=T)
ttests[[35]] <- t.test(rai.taor$RAI.dry.year1, rai.taor$RAI.wet.year1, paired=T)
ttests[[36]] <- t.test(rai.tran$RAI.dry.year1, rai.tran$RAI.wet.year1, paired=T)
ttests[[37]] <- t.test(rai.trst$RAI.dry.year1, rai.trst$RAI.wet.year1, paired=T)
ttests[[38]] <- t.test(rai.trsy$RAI.dry.year1, rai.trsy$RAI.wet.year1, paired=T)

# get output into table
tab <- map_df(ttests, tidy)

# add column for species
tab$Species <- c("AEME", "ALBU", "ATPA", "BDCR", "CEAL", "CENA", "CHPY", "CICI", "COTA", "GASA", "GEGE", "HEIC", "HEPA", "HINI", "HYAF", "ICAL", "KOEL", "LEMI", "LESE", "LOAF", "MATE", "MECA", "MUMU", "ORAF", "OTCR", "OUOU", "PACY", "PALE", "PHAF", "POLA", "RERE", "SYCA", "SYGR", "TAOR", "TRAN", "TRST", "TRSY")

# export csv
write.csv(tab, "Results/wetvsdry_ttest_year1.csv", row.names=F)


ttests <- list() # create list to store model outputs in

# run each species. there's probably a way to do as a for loop... I couldn't get it to work
ttests[[1]] <- t.test(rai.aeme$RAI.dry.year2, rai.aeme$RAI.wet.year2, paired=T)
ttests[[2]] <- t.test(rai.albu$RAI.dry.year2, rai.albu$RAI.wet.year2, paired=T)
ttests[[3]] <- t.test(rai.atpa$RAI.dry.year2, rai.atpa$RAI.wet.year2, paired=T)
ttests[[4]] <- t.test(rai.bdcr$RAI.dry.year2, rai.bdcr$RAI.wet.year2, paired=T)
ttests[[5]] <- t.test(rai.ceal$RAI.dry.year2, rai.ceal$RAI.wet.year2, paired=T)
ttests[[6]] <- t.test(rai.cena$RAI.dry.year2, rai.cena$RAI.wet.year2, paired=T)
ttests[[7]] <- t.test(rai.chpy$RAI.dry.year2, rai.chpy$RAI.wet.year2, paired=T)
ttests[[8]] <- t.test(rai.cici$RAI.dry.year2, rai.cici$RAI.wet.year2, paired=T)
ttests[[9]] <- t.test(rai.cota$RAI.dry.year2, rai.cota$RAI.wet.year2, paired=T)
ttests[[10]] <- t.test(rai.gasa$RAI.dry.year2, rai.gasa$RAI.wet.year2, paired=T)
ttests[[11]] <- t.test(rai.gege$RAI.dry.year2, rai.gege$RAI.wet.year2, paired=T)
ttests[[12]] <- t.test(rai.heic$RAI.dry.year2, rai.heic$RAI.wet.year2, paired=T)
#ttests[[13]] <- t.test(rai.hepa$RAI.dry.year2, rai.hepa$RAI.wet.year2, paired=T) can't do
# ttests[[14]] <- t.test(rai.hiam$RAI.dry.year2, rai.hiam$RAI.wet.year2, paired=T) can't do
ttests[[15]] <- t.test(rai.hini$RAI.dry.year2, rai.hini$RAI.wet.year2, paired=T)
ttests[[16]] <- t.test(rai.hyaf$RAI.dry.year2, rai.hyaf$RAI.wet.year2, paired=T)
ttests[[17]] <- t.test(rai.ical$RAI.dry.year2, rai.ical$RAI.wet.year2, paired=T)
ttests[[18]] <- t.test(rai.koel$RAI.dry.year2, rai.koel$RAI.wet.year2, paired=T)
ttests[[19]] <- t.test(rai.lemi$RAI.dry.year2, rai.lemi$RAI.wet.year2, paired=T)
ttests[[20]] <- t.test(rai.lese$RAI.dry.year2, rai.lese$RAI.wet.year2, paired=T)
ttests[[21]] <- t.test(rai.loaf$RAI.dry.year2, rai.loaf$RAI.wet.year2, paired=T)
ttests[[22]] <- t.test(rai.mate$RAI.dry.year2, rai.mate$RAI.wet.year2, paired=T)
ttests[[23]] <- t.test(rai.meca$RAI.dry.year2, rai.meca$RAI.wet.year2, paired=T)
ttests[[24]] <- t.test(rai.mumu$RAI.dry.year2, rai.mumu$RAI.wet.year2, paired=T)
ttests[[25]] <- t.test(rai.oraf$RAI.dry.year2, rai.oraf$RAI.wet.year2, paired=T)
ttests[[26]] <- t.test(rai.otcr$RAI.dry.year2, rai.otcr$RAI.wet.year2, paired=T)
ttests[[27]] <- t.test(rai.ouou$RAI.dry.year2, rai.ouou$RAI.wet.year2, paired=T)
ttests[[28]] <- t.test(rai.pacy$RAI.dry.year2, rai.pacy$RAI.wet.year2, paired=T)
ttests[[29]] <- t.test(rai.pale$RAI.dry.year2, rai.pale$RAI.wet.year2, paired=T)
ttests[[30]] <- t.test(rai.phaf$RAI.dry.year2, rai.phaf$RAI.wet.year2, paired=T)
ttests[[31]] <- t.test(rai.pola$RAI.dry.year2, rai.pola$RAI.wet.year2, paired=T)
ttests[[32]] <- t.test(rai.rere$RAI.dry.year2, rai.rere$RAI.wet.year2, paired=T)
ttests[[33]] <- t.test(rai.syca$RAI.dry.year2, rai.syca$RAI.wet.year2, paired=T)
ttests[[34]] <- t.test(rai.sygr$RAI.dry.year2, rai.sygr$RAI.wet.year2, paired=T)
ttests[[35]] <- t.test(rai.taor$RAI.dry.year2, rai.taor$RAI.wet.year2, paired=T)
ttests[[36]] <- t.test(rai.tran$RAI.dry.year2, rai.tran$RAI.wet.year2, paired=T)
ttests[[37]] <- t.test(rai.trst$RAI.dry.year2, rai.trst$RAI.wet.year2, paired=T)
ttests[[38]] <- t.test(rai.trsy$RAI.dry.year2, rai.trsy$RAI.wet.year2, paired=T)

# get output into table
tab <- map_df(ttests, tidy)

# add column for species
tab$Species <- c("AEME", "ALBU", "ATPA", "BDCR", "CEAL", "CENA", "CHPY", "CICI", "COTA", "GASA", "GEGE", "HEIC", "HINI", "HYAF", "ICAL", "KOEL", "LEMI", "LESE", "LOAF", "MATE", "MECA", "MUMU", "ORAF", "OTCR", "OUOU", "PACY", "PALE", "PHAF", "POLA", "RERE", "SYCA", "SYGR", "TAOR", "TRAN", "TRST", "TRSY")

# export csv
write.csv(tab, "Results/wetvsdry_ttest_year2.csv", row.names=F)
```

Run t-tests where we compare dry and wet in BOTH year 1 and 2.
```{r t test both years}
rai.year1 <- dplyr::select(rai, StudySite, SppCode, RAI.dry.year1, RAI.wet.year1)
names(rai.year1) <- c("StudySite", "SppCode", "RAI.dry", "RAI.wet")
rai.year2 <- dplyr::select(rai, StudySite, SppCode, RAI.dry.year2, RAI.wet.year2)
names(rai.year2) <- c("StudySite", "SppCode", "RAI.dry", "RAI.wet")
rai.long.bothyears <- rbind(rai.year1, rai.year2)

# subset by species
rai.aeme2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "AEME", ]
rai.albu2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "ALBU", ]
rai.atpa2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "ATPA", ]
rai.bdcr2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "BDCR", ]
rai.ceal2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "CEAL", ]
rai.cena2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "CENA", ]
rai.chpy2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "CHPY", ]
rai.cici2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "CICI", ]
rai.cota2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "COTA", ]
rai.gasa2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "GASA", ]
rai.gege2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "GEGE", ]
rai.heic2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "HEIC", ]
rai.hepa2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "HEPA", ]
rai.hiam2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "HIAM", ]
rai.hini2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "HINI", ]
rai.hyaf2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "HYAF", ]
rai.ical2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "ICAL", ]
rai.koel2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "KOEL", ]
rai.lemi2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "LEMI", ]
rai.lese2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "LESE", ]
rai.loaf2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "LOAF", ]
rai.mate2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "MATE", ]
rai.meca2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "MECA", ]
rai.mumu2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "MUMU", ]
rai.oraf2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "ORAF", ]
rai.otcr2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "OTCR", ]
rai.ouou2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "OUOU", ]
rai.pacy2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "PACY", ]
rai.pale2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "PALE", ]
rai.phaf2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "PHAF", ]
rai.pola2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "POLA", ]
rai.rere2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "RERE", ]
rai.syca2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "SYCA", ]
rai.sygr2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "SYGR", ]
rai.taor2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "TAOR", ]
rai.tran2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "TRAN", ]
rai.trst2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "TRST", ]
rai.trsy2 <- rai.long.bothyears[rai.long.bothyears$SppCode == "TRSY", ]

ttests <- list() # create list to store model outputs in

# run each species. there's probably a way to do as a for loop... I couldn't get it to work
ttests[[1]] <- t.test(rai.aeme2$RAI.dry, rai.aeme2$RAI.wet, paired=T)
ttests[[2]] <- t.test(rai.albu2$RAI.dry, rai.albu2$RAI.wet, paired=T)
ttests[[3]] <- t.test(rai.atpa2$RAI.dry, rai.atpa2$RAI.wet, paired=T)
ttests[[4]] <- t.test(rai.bdcr2$RAI.dry, rai.bdcr2$RAI.wet, paired=T)
ttests[[5]] <- t.test(rai.ceal2$RAI.dry, rai.ceal2$RAI.wet, paired=T)
ttests[[6]] <- t.test(rai.cena2$RAI.dry, rai.cena2$RAI.wet, paired=T)
ttests[[7]] <- t.test(rai.chpy2$RAI.dry, rai.chpy2$RAI.wet, paired=T)
ttests[[8]] <- t.test(rai.cici2$RAI.dry, rai.cici2$RAI.wet, paired=T)
ttests[[9]] <- t.test(rai.cota2$RAI.dry, rai.cota2$RAI.wet, paired=T)
ttests[[10]] <- t.test(rai.gasa2$RAI.dry, rai.gasa2$RAI.wet, paired=T)
ttests[[11]] <- t.test(rai.gege2$RAI.dry, rai.gege2$RAI.wet, paired=T)
ttests[[12]] <- t.test(rai.heic2$RAI.dry, rai.heic2$RAI.wet, paired=T)
ttests[[13]] <- t.test(rai.hepa2$RAI.dry, rai.hepa2$RAI.wet, paired=T)
#ttests[[14]] <- t.test(rai.hiam2$RAI.dry, rai.hiam2$RAI.wet, paired=T)
ttests[[15]] <- t.test(rai.hini2$RAI.dry, rai.hini2$RAI.wet, paired=T)
ttests[[16]] <- t.test(rai.hyaf2$RAI.dry, rai.hyaf2$RAI.wet, paired=T)
ttests[[17]] <- t.test(rai.ical2$RAI.dry, rai.ical2$RAI.wet, paired=T)
ttests[[18]] <- t.test(rai.koel2$RAI.dry, rai.koel2$RAI.wet, paired=T)
ttests[[19]] <- t.test(rai.lemi2$RAI.dry, rai.lemi2$RAI.wet, paired=T)
ttests[[20]] <- t.test(rai.lese2$RAI.dry, rai.lese2$RAI.wet, paired=T)
ttests[[21]] <- t.test(rai.loaf2$RAI.dry, rai.loaf2$RAI.wet, paired=T)
ttests[[22]] <- t.test(rai.mate2$RAI.dry, rai.mate2$RAI.wet, paired=T)
ttests[[23]] <- t.test(rai.meca2$RAI.dry, rai.meca2$RAI.wet, paired=T)
ttests[[24]] <- t.test(rai.mumu2$RAI.dry, rai.mumu2$RAI.wet, paired=T)
ttests[[25]] <- t.test(rai.oraf2$RAI.dry, rai.oraf2$RAI.wet, paired=T)
ttests[[26]] <- t.test(rai.otcr2$RAI.dry, rai.otcr2$RAI.wet, paired=T)
ttests[[27]] <- t.test(rai.ouou2$RAI.dry, rai.ouou2$RAI.wet, paired=T)
ttests[[28]] <- t.test(rai.pacy2$RAI.dry, rai.pacy2$RAI.wet, paired=T)
ttests[[29]] <- t.test(rai.pale2$RAI.dry, rai.pale2$RAI.wet, paired=T)
ttests[[30]] <- t.test(rai.phaf2$RAI.dry, rai.phaf2$RAI.wet, paired=T)
ttests[[31]] <- t.test(rai.pola2$RAI.dry, rai.pola2$RAI.wet, paired=T)
ttests[[32]] <- t.test(rai.rere2$RAI.dry, rai.rere2$RAI.wet, paired=T)
ttests[[33]] <- t.test(rai.syca2$RAI.dry, rai.syca2$RAI.wet, paired=T)
ttests[[34]] <- t.test(rai.sygr2$RAI.dry, rai.sygr2$RAI.wet, paired=T)
ttests[[35]] <- t.test(rai.taor2$RAI.dry, rai.taor2$RAI.wet, paired=T)
ttests[[36]] <- t.test(rai.tran2$RAI.dry, rai.tran2$RAI.wet, paired=T)
ttests[[37]] <- t.test(rai.trst2$RAI.dry, rai.trst2$RAI.wet, paired=T)
ttests[[38]] <- t.test(rai.trsy2$RAI.dry, rai.trsy2$RAI.wet, paired=T)

# get output into table
tab <- map_df(ttests, tidy)

# add column for species
tab$Species <- c("AEME", "ALBU", "ATPA", "BDCR", "CEAL", "CENA", "CHPY", "CICI", "COTA", "GASA", "GEGE", "HEIC", "HEPA", "HINI", "HYAF", "ICAL", "KOEL", "LEMI", "LESE", "LOAF", "MATE", "MECA", "MUMU", "ORAF", "OTCR", "OUOU", "PACY", "PALE", "PHAF", "POLA", "RERE", "SYCA", "SYGR", "TAOR", "TRAN", "TRST", "TRSY")

# export csv
write.csv(tab, "results/wetvsdry_ttest_bothyears.csv", row.names=F)
```

From year 1:

**When comparing RAI across seasons, using paired t-tests above (n = 55 cameras), the following species have significant differences (p<0.05) in RAI from dry to wet (based on 4-month wet season:**

more activity in WET season

  + ALBU - hartebeest
  + KOEL - waterbuck
  + RERE - reedbuck
  + SYCA - buffalo
 
 **The waterbuck and reedbuck are typically very abundant on the floodplain (we know this from aerial count data), so it makes sense that they would be more common in the camera grid in the wet season, when they disperse from the floodplain into the savanna habitat.**

more activity in DRY season (mostly small carnivores)

  + ATPA - marsh mongoose
  + BDCR - bushy-tailed mongoose
  + CICI - civet
  + GEGE - genet
  + HYAF - porcupine
  + ICAL - white-tailed mongoose
  + LEMI - hare
  + LESE - serval
  + MECA - honey badger
  + MUMU - banded mongoose
  + OTCR - bushbaby
  + PACY - baboon
  + TRST - kudu
  


From BOTH YEARS:

**When comparing RAI across seasons, using paired t-tests above, the following species have significant differences (p<0.05) in RAI from dry to wet (based on 4-month wet season:**

more activity in WET season

  + KOEL - waterbuck
  + RERE - reedbuck
 
 **The waterbuck and reedbuck are typically very abundant on the floodplain (we know this from aerial count data), so it makes sense that they would be more common in the camera grid in the wet season, when they disperse from the floodplain into the savanna habitat.**

more activity in DRY season

  + ATPA - marsh mongoose
  + LEMI - hare
  + LESE - serval
  + OTCR - bushbaby
  + CICI - civet


But should probably do this as a GLMM so that we can include study site as a random effect.
```{r GLMM version, eval = F}


# let's focus just on the LMH species
sppnames.lmh <- c("AEME", "ALBU", "CENA", "COTA", "HINI", "KOEL", "OUOU", "PHAF", "POLA", "RERE", "SYGR", "SYCA", "TAOR", "TRAN", "TRST", "TRSY")

list.glmm <- list()
for (i in 1:length(sppnames.lmh)) {
  list.glmm[[i]] <- lme(RAI ~ Season, random = list(~1|StudySite, ~1|StudySite_Year), na.action = na.omit, data = rai.long[rai.long$SppCode == sppnames.lmh[[i]],])
  print(sppnames.lmh[[i]])
  print(summary(list.glmm[[i]]))
}

```

Species in which season has a significant effect on RAI:
  + ALBU (higher in wet)
  + KOEL (higher in wet)
  + SYCA (higher in wet)
  + TRAN (higher in dry)
  + TRST (higher in dry)
  + TRSY (higher in dry)

  

## Compare seasonal RAI across species (re: traits)

#### Diet category
**Carnivores and omnivores generally appear to be less active in the wet season, but this could be related to their smaller body size.**
```{r diet by season, warning = F}
ggplot(species.rai.long, aes(x = Diet, y = log(RAI.mean), fill=Season)) + geom_boxplot()
```

#### Hempson category
```{r diet by season hempsen, warning = F}
#pdf('figures/LMH_by_season.pdf', height = 4, width = 6)
ggplot(species.rai.long.lmh, aes(x = Hempsen_category, y = log(RAI.mean), fill=Season)) + geom_boxplot()
#dev.off()
```

#### Family
First, I subset to only include common families. Not sure this tells us much interesting, other than breaking down the diet patterns at higher resolution (though diet and family aren't perfectly correlated).
```{r family by season, warning = F}
# subset to only common families (Bovidae, Cercopithecidae, Herpestidae, Suidae, Viverridae)
species.rai.long.familysubset <- species.rai.long[species.rai.long$Family == "Bovidae" | species.rai.long$Family == "Cercopithecidae" | species.rai.long$Family == "Herpestidae" | species.rai.long$Family == "Suidae" | species.rai.long$Family == "Viverridae",]

ggplot(species.rai.long.familysubset, aes(x = Family, y = log(RAI.mean), fill=Season)) + geom_boxplot()
```

#### Body mass
The smallest animals have a lower RAI in the wet season, which again is likely due to lower detection rates in high grass. Generally interesting to see that the "large" category has highest activity at all times of year.

I don't actually remember why I put the breaks where they did, but the breakdown is as follows:

* Small (mostly mongooses): marsh mongoose, bushy-tailed mongoose, slender mongoose, dwarf mongoose, genet, large grey mongoose, white-tailed mongoose, banded mongoose, hare, bushbaby
* Medium: baboon, oribi, samango, red duiker, civet, porcupine, serval, pangolin, honey badger, common duiker
* Large: impala, reedbuck, warthog, nyala, aardvark, bushbuck, bushpig
* Very large: waterbuck, wildebeest, hartebeest, buffalo, eland, elephant, sable, kudu, hippo, lion

```{r mass category by season, warning = F}
# change order of factor levels
species.rai.long$Mass_category = factor(species.rai.long$Mass_category, levels(species.rai.long$Mass_category)[c(3,2,1,4)])
ggplot(species.rai.long, aes(x = Mass_category, y = log(RAI.mean), fill=Season)) + geom_boxplot()
```

This breaks the body mass categories down by individual animals, where the x axis orders animals from smallest to largest body size (on a log scale). Red dots correspond to dry season RAI, and black dots to wet season RAI (also both on a log scale). I tried to color the lines according to whether there was an increase or decrease in RAI across seasons but couldn't figure it out.
```{r body mass by season, warning = F}
# WEIGHT with both dry and wet seasons, with log transformation for both weight and RAI
# add line segments between the dry and wet seasons
ggplot(species.rai, aes(x = log(Weight), y = log(RAI.wet.year1.mean))) + geom_point() +
    geom_text(aes(label=CommName),hjust=0, vjust=0) + 
    geom_point(aes(y=log(RAI.dry.year1.mean)), color="red") +
    geom_segment(aes(x=log(Weight), y = log(RAI.wet.year1.mean), xend = log(Weight), yend = log(RAI.dry.year1.mean)), data=species.rai, linetype=2)
```

#### Typical activity patterns
```{r activity patterns by season, warning = F}
ggplot(species.rai.long, aes(x = Activity_pattern, y = log(RAI.mean), fill=Season)) + geom_boxplot()
```

#### Sociality
```{r sociality by season, warning = F}
ggplot(species.rai.long, aes(x = Sociality, y = log(RAI.mean), fill=Season)) + geom_boxplot()
```

## Linking camera covariates to species RAI
What factors influence seasonal RAI for each species?

Explore the effects of covariates on single-season RAI. This glmulti function assesses every possible model combination and compares them based on AIC. 

#### More efficiently-run GLMs - spatial covariates only

Dry season models, with the following covariates: all poaching (binary), high poaching (binary), fire return interval, distance to major road, distance to Lake Urema, distance to nearest pan, distance to nearest river, tree density within 250m, termite mound density within 250m, pan density within 250m. In this case, store outputs in a list, and use a loop.
```{r glm subsets, echo = F}
# make a list of all species datasets. In retrospect, when doing this above, I should have subset into a list
species.datasets <- list(rai.aeme, rai.albu, rai.atpa, rai.bdcr, rai.ceal, rai.cena, rai.chpy, rai.cici, rai.cota, rai.gasa, rai.gege, rai.heic, rai.hepa, rai.hiam, rai.hini, rai.hyaf, rai.ical, rai.koel, rai.lemi, rai.lese, rai.loaf, rai.mate, rai.meca, rai.mumu, rai.oraf, rai.otcr, rai.ouou, rai.pacy, rai.pale, rai.phaf, rai.pola, rai.rere, rai.syca, rai.sygr, rai.taor, rai.tran, rai.trst, rai.trsy)

species.datasets.lmh <- list(rai.aeme, rai.albu, rai.cena, rai.cota, rai.hiam, rai.hini, rai.koel, rai.loaf, rai.ouou, rai.phaf, rai.pola, rai.rere, rai.syca, rai.sygr, rai.taor, rai.tran, rai.trst, rai.trsy)

# make list of common names for labeling graphs below, based on the above list
common.names <- list()
for (i in 1:38) {
  common.names[[i]] <- species.datasets[[i]][1,3] # first row of the "CommName" column (all rows have the same value)
}

common.names.lmh <- list()
for (i in 1:18) {
  common.names.lmh[[i]] <- species.datasets.lmh[[i]][1,3] # first row of the "CommName" column (all rows have the same value)
}
```

Compare RAI at a given camera year to year.
```{r compare cameras between years}
plotlist <- list()
for (i in 1:38) {
  plotlist[[i]] <- ggplot(species.datasets[[i]], aes(x = log(RAI.dry.year1), y = log(RAI.dry.year2))) + 
    geom_point() +
    ggtitle(common.names[[i]])
  print(plotlist[[i]])
}

```


```{r glm spatial covariates}
## make lists to store model output2
#model.outputs.dry.year1 <- list() 
#model.outputs.wet.year1 <- list() 
#
## run for loop for all dry season models (exclude hippo dataframe, will cause errors, no dry season records)
#for (i in c(1:13, 15:38)) {
#  model.outputs.dry.year1[[i]] <- glmulti(RAI.dry.year1 ~ poaching.high + fire.interval + road.major.distance + urema.distance + #pan.distance + tree.hansen + termite.large.count.100m + panscon.250m + lion.dry, 
#                data = species.datasets[[i]], # change datasets for each species
#                method = "h", 
#                crit="aic", # use AIC as criterion
#                level=1) # only main effects are to be used, no interactions
#}
## for hippo:
#model.outputs.dry.year1[[14]] <- NA
#
## run for loop for all wet season models (exclude dwarf mongoose dataframe, will cause errors, no dry season records)
#for (i in c(1:12, 14:38)) {
#  model.outputs.wet.year1[[i]] <- glmulti(RAI.wet.year1 ~ poaching.high + fire.interval + road.major.distance + urema.distance + #tree.250m + termites.250m + pans.250m + lion.wet, 
#                data = species.datasets[[i]], # change datasets for each species
#                method = "h", 
#                crit="aic", # use AIC as criterion
#                level=1) # only main effects are to be used, no interactions
#}
## for dwarf mongoose:
#model.outputs.wet.year1[[13]] <- NA
```

Print the best models.
```{r print best models}
#for (i in 1:38) {
#  for (i in c(1:13, 15:38)) {
#    print(model.outputs.dry.year1[[i]]@objects[[1]])
#  }
#  for (i in c(1:12, 14:38)) {
#    print(model.outputs.wet.year1[[i]]@objects[[1]])
#  }
#}
```


Combine the year 1 and 2 data to increase the sample size (pseudoreplication, but correlations for many species for a given camera year-to-year are weak so I'm going to give it a go). (Update 3/28/19 - see below for code that does incorporate camera as a random effect)
```{r glm combining 1 and 2 data}
## DRY
#model.outputs.dry.combined <- list()
#averaged.results.dry.combined <- list()
#
#for (i in c(1:4, 6:17)) {
#  model.outputs.dry.combined[[i]] <- glmulti(RAI ~ poaching.high + fire.interval + road.major.distance + #urema.distance + tree.hansen + termite.count.100m + pans.250m + settlement.distance + lion.dry, 
#                data = long.lmh.list.dry[[i]], # change datasets for each species
#                method = "h", 
#                crit="aic", # use AIC as criterion
#                level=1) # only main effects are to be used, no interactions
#  
#  #averaged.results.dry.combined[[i]] <- as.data.frame(coef(model.outputs.dry.combined[[i]], select = #as.numeric(2)))
#  averaged.results.dry.combined[[i]] <- as.data.frame(coef(model.outputs.dry.combined[[i]]))
#  names(averaged.results.dry.combined[[i]]) <- c("Estimate", "Variance", "Num_models", "Importance", #"PlusMinus")
#  averaged.results.dry.combined[[i]]$LowerCI <- averaged.results.dry.combined[[i]]$Estimate - #averaged.results.dry.combined[[i]]$PlusMinus
#  averaged.results.dry.combined[[i]]$UpperCI <- averaged.results.dry.combined[[i]]$Estimate + #averaged.results.dry.combined[[i]]$PlusMinus
#  averaged.results.dry.combined[[i]]$CommName <- common.names.lmh[[i]]
#  averaged.results.dry.combined[[i]] <- cbind(rownames(averaged.results.dry.combined[[i]]), #data.frame(averaged.results.dry.combined[[i]], row.names=NULL))
#}
#model.outputs.dry.combined[[5]] <- NA
#averaged.results.dry.combined.df <- do.call("rbind", averaged.results.dry.combined)
#averaged.results.dry.combined.df$Season <- "dry"
#names(averaged.results.dry.combined.df) <- c("Covariate", names(averaged.results.dry.combined.df)[2:10])
#
## WET
#
#model.outputs.wet.combined <- list()
#averaged.results.wet.combined <- list()
#
#for (i in c(1:17)) {
#  model.outputs.wet.combined[[i]] <- glmulti(RAI ~ poaching.high + fire.interval + road.major.distance + #urema.distance + tree.hansen + termite.count.100m + pans.250m + settlement.distance + lion.wet, 
#                data = long.lmh.list.wet[[i]], # change datasets for each species
#                method = "h", 
#                crit="aic", # use AIC as criterion
#                level=1) # only main effects are to be used, no interactions
#  #  averaged.results.wet.combined[[i]] <- as.data.frame(coef(model.outputs.wet.combined[[i]], select = #as.numeric(2)))
#  averaged.results.wet.combined[[i]] <- as.data.frame(coef(model.outputs.wet.combined[[i]]))
#  names(averaged.results.wet.combined[[i]]) <- c("Estimate", "Variance", "Num_models", "Importance", #"PlusMinus")
#  averaged.results.wet.combined[[i]]$LowerCI <- averaged.results.wet.combined[[i]]$Estimate - #averaged.results.wet.combined[[i]]$PlusMinus
#  averaged.results.wet.combined[[i]]$UpperCI <- averaged.results.wet.combined[[i]]$Estimate + #averaged.results.wet.combined[[i]]$PlusMinus
#  averaged.results.wet.combined[[i]]$CommName <- common.names.lmh[[i]]
#  averaged.results.wet.combined[[i]] <- cbind(rownames(averaged.results.wet.combined[[i]]), #data.frame(averaged.results.wet.combined[[i]], row.names=NULL))
#}
#averaged.results.wet.combined.df <- do.call("rbind", averaged.results.wet.combined)
#averaged.results.wet.combined.df$Season <- "wet"
#names(averaged.results.wet.combined.df) <- c("Covariate", names(averaged.results.wet.combined.df)[2:10])
#
#averaged.results.combined.df <- rbind(averaged.results.dry.combined.df, averaged.results.wet.combined.df)
#averaged.results.combined.df <- join(averaged.results.combined.df, species)
```

Do this better include camera as a random effect.

I first tried it with glmulti but it didn't work. I used code from Sami to make a wrapper for random effect, and successfully ran glmulti with a random effect. But then I couldn't get the model averaging to work (kept getting error about duplicate values, even though that wasn't the issue.)
```{r glm combining 1 and 2 data with random effect - FAIL}
#form_glmulti = as.formula(paste("RAI ~ poaching.high + fire.interval + road.major.distance + #urema.distance + tree.hansen + termite.count.100m + pans.250m + lion.dry"))
#
## The wrapper function for linear mixed-models
#lmer.glmulti <- function(formula, data, random = "", ...) {
#  lmer(paste(deparse(formula),random), data = data, REML=F, ...)
#}


# DRY
#model.outputs.dry.combined <- list()
#averaged.results.dry.combined <- list()

#for (i in c(1:4, 6:17)) {
#  random_effect <- as.factor(long.lmh.list.dry[[1]]$StudySite)
#
#  model.outputs.dry.combined[[i]] <- glmulti(form_glmulti, random="+(1|random_effect)", 
#                                          data=long.lmh.list.dry[[i]], 
#                                          method="h", 
#                                          crit="aic",
#                                          fitfunc=lmer.glmulti, 
#                                          intercept=TRUE, 
#                                          marginality=FALSE, 
#                                          level=1)
#  
  #averaged.results.dry.combined[[i]] <- as.data.frame(coef(model.outputs.dry.combined[[i]], select = as.numeric(2)))
  #averaged.results.dry.combined[[i]] <- as.data.frame(coef(model.outputs.dry.combined[[i]]))
  #names(averaged.results.dry.combined[[i]]) <- c("Estimate", "Variance", "Num_models", "Importance", "PlusMinus")
  #averaged.results.dry.combined[[i]]$LowerCI <- averaged.results.dry.combined[[i]]$Estimate - averaged.results.dry.combined[[i]]$PlusMinus
  #averaged.results.dry.combined[[i]]$UpperCI <- averaged.results.dry.combined[[i]]$Estimate + averaged.results.dry.combined[[i]]$PlusMinus
  #averaged.results.dry.combined[[i]]$CommName <- common.names.lmh[[i]]
  #averaged.results.dry.combined[[i]] <- cbind(rownames(averaged.results.dry.combined[[i]]), data.frame(averaged.results.dry.combined[[i]], row.names=NULL))
#}

# 
#model.outputs.dry.combined.list <- list()
#for (i in 1:length(model.outputs.dry.combined[[1]]@objects)) {
#  model.outputs.dry.combined.list[[i]] <- model.outputs.dry.combined[[1]]@objects[[i]]
#}
#model.outputs.dry.combined.list <- unique(model.outputs.dry.combined.list) # this doesn't work

# model.avg doesn't work, it says that there are duplicate models but there aren't
# test <- model.avg(model.outputs.dry.combined.list)


```

##### MUMIN RESULTS

I tried it with MuMIN, and DID get it working.
```{r glm combining 1 and 2 data with random effect}

## DRY SEASON

model.outputs.dry.combined <- list()
averaged.results.dry.combined <- list()

for (i in c(1:4, 6:18)) {
  
  data.to.use <- long.lmh.list.dry[[i]] # dredge gives an error if there is a bracket in the data set name, so move into another data frame
  data.to.use <- dplyr::select(data.to.use, RAI, StudySite, poaching, poaching.high, fire.interval, road.major.distance, urema.distance, tree.hansen, termite.count.100m, panscon.250m, lion.dry, pan.distance, settlement.distance, river.distance, panscon.offflood.250) # select all variables to use; this way, we can use complete.cases and only remove lines with NA RAI
  data.to.use <- data.to.use[complete.cases(data.to.use),] # there is an error in lme if there are NAs, but then if I set na.action = na.omit in the lme model then there is an error in the dredging, so this is the way it has to be
  
    data.to.use$RAI.norm <- zstd(data.to.use$RAI)

  model.outputs.dry.combined[[i]] <- lme(RAI.norm ~ poaching + fire.interval + river.distance +
                                           road.major.distance + urema.distance + tree.hansen + 
                                           termite.count.100m + panscon.250m + lion.dry, 
                                       data = data.to.use,
                                       random = ~ 1|StudySite, 
                                       method = "ML",
                                       keep.data = TRUE)
  
  fit.dredge <- dredge(model.outputs.dry.combined[[i]], rank = "AIC")
  
  (attr(fit.dredge, "rank.call"))
  # Get the models (fitted by REML, as in the global model)
  fmList <- get.models(fit.dredge, subset = delta < 2)
  # Because the models originate from 'dredge(..., rank = AICc, REML = FALSE)',
  # the default weights in 'model.avg' are ML based:
  averaged.results.dry.combined[[i]] <- model.avg(fmList)
  
  # can't figure out how to extract the estimate AND standard error from the model averaging output. It's not in any of the elements in the list of model.avg, but IS in the summary. But how to isolate??? I DID figure out how to get the estimate and confidence intervals, so that's what I've done here
  
  estimates <- as.data.frame(averaged.results.dry.combined[[i]][[2]])
  
  # take only full estimates, not subset estimates
  estimates <- estimates[1,]
  # move variable names into first column
  estimates <- rbind(Factor = names(estimates), estimates)
  # transpose, keep names
  estimates <- as.data.frame(t(estimates), row.names=F)
  # change names
  names(estimates) <- c("Covariate", "Estimate")
  
  # now wrangle confidence intervals
  confidence.intervals <- confint(averaged.results.dry.combined[[i]])
  # move variable names into first column
  row.names.placeholder <- rownames(confidence.intervals)
  rownames(confidence.intervals) <- NULL
  confidence.intervals <- as.data.frame(cbind(row.names.placeholder,confidence.intervals))
  names(confidence.intervals) <- c("Covariate", "LowerCI", "UpperCI")
  averaged.results.dry.combined[[i]] <- cbind(estimates, confidence.intervals[,2:3])
  averaged.results.dry.combined[[i]]$CommName <- common.names.lmh[[i]]
  
  # and get relative importance values
  importance.values <- as.data.frame(importance(fmList))
  row.names.placeholder <- rownames(importance.values)
  importance.values <- as.data.frame(cbind(row.names.placeholder,importance.values))
  names(importance.values) <- c("Covariate", "Importance")
  averaged.results.dry.combined[[i]] <- left_join(averaged.results.dry.combined[[i]], importance.values)
  

}

model.outputs.dry.combined[[5]] <- NA
averaged.results.dry.combined[[5]] <- NA

averaged.results.dry.combined.df <- do.call("rbind", averaged.results.dry.combined)
averaged.results.dry.combined.df$Season <- "dry"

## WET SEASON

model.outputs.wet.combined <- list()
averaged.results.wet.combined <- list()

for (i in c(1:18)) {
  
  data.to.use <- long.lmh.list.wet[[i]] # dredge gives an error if there is a bracket in the data set name, so move into another data frame
  data.to.use <- dplyr::select(data.to.use, RAI, StudySite, poaching.high, poaching, fire.interval, road.major.distance, urema.distance, tree.hansen, termite.count.100m, panscon.250m, lion.wet, pan.distance, settlement.distance, river.distance, panscon.offflood.250) # select all variables to use; this way, we can use complete.cases and only remove lines with NA RAI
  data.to.use <- data.to.use[complete.cases(data.to.use),] # there is an error in lme if there are NAs, but then if I set na.action = na.omit in the lme model then there is an error in the dredging, so this is the way it has to be
  
  data.to.use$RAI.norm <- zstd(data.to.use$RAI)
  
  model.outputs.wet.combined[[i]] <- lme(RAI.norm ~ poaching + fire.interval + river.distance +
                                           road.major.distance + urema.distance + tree.hansen + 
                                           termite.count.100m + panscon.250m + lion.wet, 
                                       data = data.to.use,
                                       random = ~ 1|StudySite, 
                                       method = "ML",
                                       keep.data = TRUE)
  
  fit.dredge <- dredge(model.outputs.wet.combined[[i]], rank = "AIC")
  
  (attr(fit.dredge, "rank.call"))
  # Get the models (fitted by REML, as in the global model)
  fmList <- get.models(fit.dredge, subset = delta < 2)
  # Because the models originate from 'dredge(..., rank = AICc, REML = FALSE)',
  # the default weights in 'model.avg' are ML based:
  averaged.results.wet.combined[[i]] <- model.avg(fmList)
  
  # can't figure out how to extract the estimate AND standard error from the model averaging output. It's not in any of the elements in the list of model.avg, but IS in the summary. But how to isolate??? I DID figure out how to get the estimate and confidence intervals, so that's what I've done here
  
  estimates <- as.data.frame(averaged.results.wet.combined[[i]][[2]])
  
  # take only full estimates, not subset estimates
  estimates <- estimates[1,]
  # move variable names into first column
  estimates <- rbind(Factor = names(estimates), estimates)
  # transpose, keep names
  estimates <- as.data.frame(t(estimates), row.names=F)
  # change names
  names(estimates) <- c("Covariate", "Estimate")
  
  # now wrangle confidence intervals
  confidence.intervals <- confint(averaged.results.wet.combined[[i]])
  # move variable names into first column
  row.names.placeholder <- rownames(confidence.intervals)
  rownames(confidence.intervals) <- NULL
  confidence.intervals <- as.data.frame(cbind(row.names.placeholder,confidence.intervals))
  names(confidence.intervals) <- c("Covariate", "LowerCI", "UpperCI")
  averaged.results.wet.combined[[i]] <- cbind(estimates, confidence.intervals[,2:3])
  averaged.results.wet.combined[[i]]$CommName <- common.names.lmh[[i]]

  # and get relative importance values
  importance.values <- as.data.frame(importance(fmList))
  row.names.placeholder <- rownames(importance.values)
  importance.values <- as.data.frame(cbind(row.names.placeholder,importance.values))
  names(importance.values) <- c("Covariate", "Importance")
  averaged.results.wet.combined[[i]] <- left_join(averaged.results.wet.combined[[i]], importance.values)  
  
}

averaged.results.wet.combined.df <- do.call("rbind", averaged.results.wet.combined)
averaged.results.wet.combined.df$Season <- "wet"

averaged.results.combined.df <- rbind(averaged.results.dry.combined.df, averaged.results.wet.combined.df)

averaged.results.combined.df$Estimate <- as.numeric(as.character(averaged.results.combined.df$Estimate))
averaged.results.combined.df$LowerCI <- as.numeric(as.character(averaged.results.combined.df$LowerCI))
averaged.results.combined.df$UpperCI <- as.numeric(as.character(averaged.results.combined.df$UpperCI))

library(forcats)
averaged.results.combined.df$Covariate <- fct_collapse(averaged.results.combined.df$Covariate, lion = c("lion.dry","lion.wet"))
```

##### Data frame with 0s instead of NA

Create data frame with unique covariate-season-species combinations, so that any covariates that don't appear in species models will show up in the model averaged estimates as 0.
```{r fill in NA with 0}
covariates.all <- c("(Intercept)", "poaching", "fire.interval", "road.major.distance", "urema.distance", "tree.hansen", "termite.count.100m", "panscon.250m",  "river.distance", "lion")
seasons <- c("wet", "dry")
common.names.lmh2 <- rbind(c("Impala", "Hartebeest", "Duiker_red", "Wildebeest", "Hippo", "Sable_antelope", "Waterbuck", "Elephant", "Oribi", "Warthog", "Bushpig", "Reedbuck", "Buffalo", "Duiker_common", "Eland", "Nyala", "Kudu", "Bushbuck"))
covariate.sppcode.pairs <- expand.grid(covariates.all, common.names.lmh2, seasons)
names(covariate.sppcode.pairs) <- c("Covariate", "CommName", "Season")
averaged.results.combined.df2 <- left_join(covariate.sppcode.pairs, averaged.results.combined.df)

# replace NA with 0
averaged.results.combined.df2$Estimate[is.na(averaged.results.combined.df2$Estimate)] <- 0
averaged.results.combined.df2$LowerCI[is.na(averaged.results.combined.df2$LowerCI)] <- 0
averaged.results.combined.df2$UpperCI[is.na(averaged.results.combined.df2$UpperCI)] <- 0

averaged.results.combined.df <- join(averaged.results.combined.df, species)
averaged.results.combined.df2 <- join(averaged.results.combined.df2, species)

# order by body size
averaged.results.combined.df$CommName_Full <- reorder(averaged.results.combined.df$CommName_Full, averaged.results.combined.df$Weight)
averaged.results.combined.df2$CommName_Full <- reorder(averaged.results.combined.df2$CommName_Full, averaged.results.combined.df2$Weight)

# create another factor w/ collapsed diet categories
averaged.results.combined.df$Hempsen_diet2 <- fct_collapse(averaged.results.combined.df$Hempsen_diet, grazer = c("GRO","GRV"), nongrazer = c("BGI", "BRW", "FRG", "GEN"))

averaged.results.combined.df2$Hempsen_diet2 <- fct_collapse(averaged.results.combined.df2$Hempsen_diet, grazer = c("GRO","GRV"), nongrazer = c("BGI", "BRW", "FRG", "GEN"))

# export for later
write.csv(averaged.results.combined.df, 'Results/RAI/averaged.results.combined.df.csv', row.names=F)
write.csv(averaged.results.combined.df2, 'Results/RAI/averaged.results.combined.df2.csv', row.names=F)

# read in
averaged.results.combined.df <- read.csv('Results/RAI/averaged.results.combined.df.csv')
averaged.results.combined.df2 <- read.csv('Results/RAI/averaged.results.combined.df2.csv')
```


###### Side note: take a look at different pan classifications and poaching layers

```{r explore pan covariates}
# 250m isn't great; there is one camera that is a HUGE outlier and it's just near the floodplain, not actually in an area with a lot of pans
# 250m
ggplot(subset(rai.long, LMH=="yes"), aes(x=pans.250m, y = log(RAI), col = Season)) +
  geom_point() + 
  facet_wrap(~ SppCode, scales = "free") +
  geom_smooth(method='lm') 

# 250m cons
ggplot(subset(rai.long, LMH=="yes"), aes(x=panscon.250m, y = log(RAI), col = Season)) +
  geom_point() + 
  facet_wrap(~ SppCode, scales = "free") +
  geom_smooth(method='lm')

# pan distance
ggplot(subset(rai.long, LMH=="yes"), aes(x=pan.distance, y = log(RAI), col = Season)) +
  geom_point() + 
  facet_wrap(~ SppCode, scales = "free") +
  geom_smooth(method='lm')

# poaching high
ggplot(subset(rai.long, LMH=="yes"), aes(x=as.factor(poaching.high), y = log(RAI), fill = Season)) +
  geom_boxplot() + 
  facet_wrap(~ SppCode, scales = "free") 

# poaching all
ggplot(subset(rai.long, LMH=="yes"), aes(x=as.factor(poaching), y = log(RAI), col = Season)) +
  geom_point() + 
  facet_wrap(~ SppCode, scales = "free") +
  geom_smooth(method='lm')
```


## Plot the estimates of the factors in the top LMH models

##### Fire
```{r plot RAI estimates - fire, eval = F}
## FIRE FREQUENCY
pdf('Figures/RAI/RAI_fire.pdf', height = 5, width = 7)
ggplot(subset(averaged.results.combined.df2, Covariate == "fire.interval"), aes(x=CommName_Full, y=Estimate, col = Season)) + 
  geom_errorbar(aes(ymin = LowerCI, ymax = UpperCI), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  geom_hline(aes(yintercept = 0), linetype="dashed") +
#  facet_grid(~Hempsen_category, space = "free_x", scales = "free_x") +
  labs(title = "Fire frequency & RAI", tag = "A)") +
  xlab("Species") +
  ylab("Model-Averaged Coefficient")
dev.off()

ggplot(subset(averaged.results.combined.df2, Covariate == "fire.interval"), aes(x=CommName_Full, y=Importance, fill = Season)) +
  geom_col(position = position_dodge(width = 1)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Fire Frequency")

pdf('Figures/RAI/RAI_fire_nichewidth.pdf', width = 7, height = 4, useDingbats = F)
ggplot(subset(averaged.results.combined.df2, Covariate == "fire.interval"), aes(x=Pansu_pop_niche_width, y=Estimate, col = Season, fill = Season)) + 
#  geom_errorbar(aes(ymin=LCI, ymax=UCI), width=.1) +
  geom_point() +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
#  geom_hline(aes(yintercept = 0), linetype="dashed") +
  geom_smooth(method='lm') +
  facet_grid(~Season) +
#  labs(title = "Fire frequency") +
  xlab("Dietary Diversity (Niche Width)") +
  ylab("Model-Averaged Coefficient for Fire Frequency")
dev.off()

# are niche width and percent grass correlated?
ggplot(subset(averaged.results.combined.df2, Covariate == "fire.interval"), aes(x=Pansu_pop_niche_width, y=Pansu_percent_gras_RRA)) + 
#  geom_errorbar(aes(ymin=LCI, ymax=UCI), width=.1) +
  geom_point() +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
#  geom_hline(aes(yintercept = 0), linetype="dashed") +
  geom_smooth(method='lm') 

# with fewer Hempsen diet layers - boxplot
ggplot(subset(averaged.results.combined.df2, Covariate == "fire.interval" & LMH =="yes"), aes(x=Season, y=Estimate, fill = Season)) + 
  labs(title = "Fire frequency by diet") +
  geom_boxplot() +
  facet_grid(~Hempsen_diet2)

pdf('Figures/RAI/RAI_fire_grassdiet.pdf', height = 4, width = 7, useDingbats = F)
ggplot(subset(averaged.results.combined.df2, Covariate == "fire.interval"), aes(x=Pansu_percent_gras_RRA, y=Estimate, col = Season, fill = Season)) + 
#  geom_errorbar(aes(ymin=LCI, ymax=UCI), width=.1) +
  geom_point() +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
#  geom_hline(aes(yintercept = 0), linetype="dashed") +
  geom_smooth(method='lm') +
  facet_grid(~Season) +
#  labs(title = "Tree Cover") +
  xlab("Percent Grass in Diet") +
  ylab("Model-Averaged Coefficient for Fire Frequency")
dev.off()

fit <- lm(Estimate ~ Pansu_percent_gras_RRA, data = subset(averaged.results.combined.df2, Covariate == "fire.interval" & Season == 'dry'))
summary(fit)
fit <- lm(Estimate ~ Pansu_percent_gras_RRA, data = subset(averaged.results.combined.df2, Covariate == "fire.interval" & Season == 'wet'))
summary(fit)
```

##### Pans
```{r rai pans}
## PANS
#pdf('Figures/RAI/RAI_pans.pdf', height = 5, width = 7)
ggplot(subset(averaged.results.combined.df2, Covariate == "panscon.250m"), aes(x=CommName_Full, y=Estimate, col = Season)) + 
  geom_errorbar(aes(ymin = LowerCI, ymax = UpperCI), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  geom_hline(aes(yintercept = 0), linetype="dashed") +
#  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Pan density & RAI", tag = "A)") +
  xlab("Species") +
  ylab("Model-Averaged Coefficient")
#dev.off()

ggplot(subset(averaged.results.combined.df2, Covariate == "panscon.250m"), aes(x=CommName_Full, y=Importance, fill = Season)) +
  geom_col(position = position_dodge(width = 1)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Pan Density")
```

##### Poaching
```{r rai poaching}
## POACHING
#pdf('Figures/RAI/RAI_poaching.pdf', height = 5, width = 7)
ggplot(subset(averaged.results.combined.df2, Covariate == "poaching"), aes(x=CommName_Full, y=Estimate, col = Season)) + 
  geom_errorbar(aes(ymin = LowerCI, ymax = UpperCI), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  geom_hline(aes(yintercept = 0), linetype="dashed") +
#  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Poaching & RAI", tag = "A)") +
  xlab("Species") +
  ylab("Model-Averaged Coefficient")
#dev.off()

ggplot(subset(averaged.results.combined.df2, Covariate == "poaching"), aes(x=CommName_Full, y=Importance, fill = Season)) +
  geom_col(position = position_dodge(width = 1)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Poaching")
```

##### Road
```{r rai road}
## DISTANCE TO ROAD
#pdf('Figures/RAI/RAI_road.pdf', height = 5, width = 7)
ggplot(subset(averaged.results.combined.df2, Covariate == "road.major.distance"), aes(x=CommName_Full, y=Estimate, col = Season)) + 
  geom_errorbar(aes(ymin = LowerCI, ymax = UpperCI), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  geom_hline(aes(yintercept = 0), linetype="dashed") +
#  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Roads & RAI", tag = "A)") +
  xlab("Species") +
  ylab("Model-Averaged Coefficient")
#dev.off()

ggplot(subset(averaged.results.combined.df2, Covariate == "road.major.distance"), aes(x=CommName_Full, y=Importance, fill = Season)) +
  geom_col(position = position_dodge(width = 1)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Distance to Road")
```

##### River
```{r rai river}
## DISTANCE TO RIVER
#pdf('Figures/RAI/RAI_river.pdf', height = 5, width = 7)
ggplot(subset(averaged.results.combined.df2, Covariate == "river.distance"), aes(x=CommName_Full, y=Estimate, col = Season)) + 
  geom_errorbar(aes(ymin = LowerCI, ymax = UpperCI), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  geom_hline(aes(yintercept = 0), linetype="dashed") +
#  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Rivers & RAI", tag = "A)") +
  xlab("Species") +
  ylab("Model-Averaged Coefficient")
#dev.off()

## DISTANCE TO SETTLEMENT
#pdf('Figures/RAI/RAI_settlement.pdf', height = 5, width = 7)
#ggplot(subset(averaged.results.combined.df2, Covariate == "settlement.distance"), #aes(x=CommName_Full, y=Estimate, col = Season)) + 
#  geom_errorbar(aes(ymin = LowerCI, ymax = UpperCI), width=.1, position = #position_dodge(width = .75)) +
#  geom_point(position = position_dodge(width = .75)) +
#  theme(axis.text.x=element_text(angle=45,hjust=1)) +
#  geom_hline(aes(yintercept = 0), linetype="dashed") +
##  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
#  labs(title = "Distance to Settlement")
#dev.off()

#ggplot(subset(averaged.results.combined.df2, Covariate == "settlement.distance"), #aes(x=CommName_Full, y=Importance, fill = Season)) +
#  geom_col(position = position_dodge(width = 1)) +
#  theme(axis.text.x=element_text(angle=45,hjust=1)) +
#  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
#  labs(title = "Distance to Settlement")
```

##### Termites
```{r rai termite}             
## TERMITE MOUND DENSITY
#pdf('Figures/RAI/RAI_termite.pdf', height = 5, width = 7)
ggplot(subset(averaged.results.combined.df2, Covariate == "termite.count.100m"), aes(x=CommName_Full, y=Estimate, col = Season)) + 
  geom_errorbar(aes(ymin = LowerCI, ymax = UpperCI), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  geom_hline(aes(yintercept = 0), linetype="dashed") +
#  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Termite mound density & RAI", tag = "A)") +
  xlab("Species") +
  ylab("Model-Averaged Coefficient")
#dev.off()

ggplot(subset(averaged.results.combined.df2, Covariate == "termite.count.100m"), aes(x=CommName_Full, y=Importance, fill = Season)) +
  geom_col(position = position_dodge(width = 1)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Termite Mound Density")

#pdf('Figures/RAI/RAI_termite_nichewidth.pdf', width = 7, height = 5)
ggplot(subset(averaged.results.combined.df2, Covariate == "termite.count.100m"), aes(x=Pansu_pop_niche_width, y=Estimate, col = Season, fill = Season)) + 
#  geom_errorbar(aes(ymin=LCI, ymax=UCI), width=.1) +
  geom_point() +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
#  geom_hline(aes(yintercept = 0), linetype="dashed") +
  geom_smooth(method='lm') +
  facet_grid(~Season) +
  labs(title = "Termite mound density") +
  xlab("Niche Width") +
  ylab("Model-Averaged Coefficient")
#dev.off()
```

##### Tree
```{r rai tree}
## TREE COVER
#pdf('Figures/RAI/RAI_tree.pdf', height = 5, width = 7)
ggplot(subset(averaged.results.combined.df2, Covariate == "tree.hansen"), aes(x=CommName_Full, y=Estimate, col = Season)) + 
  geom_errorbar(aes(ymin = LowerCI, ymax = UpperCI), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  geom_hline(aes(yintercept = 0), linetype="dashed") +
#  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Tree cover & RAI", tag = "A)") +
  xlab("Species") +
  ylab("Model-Averaged Coefficient")
#dev.off()

ggplot(subset(averaged.results.combined.df2, Covariate == "tree.hansen"), aes(x=CommName_Full, y=Importance, fill = Season)) +
  geom_col(position = position_dodge(width = 1)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Tree Cover")

ggplot(subset(averaged.results.combined.df2, Covariate == "tree.hansen" & LMH =="yes"), aes(x=Season, y=Estimate, fill = Season)) + 
  labs(title = "Tree cover by diet") +
#  geom_boxplot() +
#  geom_jitter() +
  geom_dotplot(binaxis = 'y', stackdir = 'center',
                 position = position_dodge()) +
  facet_grid(~Hempsen_diet2)

#pdf('Figures/RAI/RAI_tree_grassdiet.pdf', height = 4, width = 7, useDingbats = F)
ggplot(subset(averaged.results.combined.df2, Covariate == "tree.hansen"), aes(x=Pansu_percent_gras_RRA, y=Estimate, col = Season, fill = Season)) + 
#  geom_errorbar(aes(ymin=LCI, ymax=UCI), width=.1) +
  geom_point() +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
#  geom_hline(aes(yintercept = 0), linetype="dashed") +
  geom_smooth(method='lm') +
  facet_grid(~Season) +
#  labs(title = "Tree Cover") +
  xlab("Percent Grass in Diet") +
  ylab("Model-Averaged Coefficient for Tree Cover")
#dev.off()

#pdf('Figures/RAI/RAI_tree_groupsize.pdf', height = 5, width = 7)
ggplot(subset(averaged.results.combined.df2, Covariate == "tree.hansen"), aes(x=X10.2_SocialGrpSize, y=Estimate, col = Season, fill = Season)) + 
#  geom_errorbar(aes(ymin=LCI, ymax=UCI), width=.1) +
  geom_point() +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
#  geom_hline(aes(yintercept = 0), linetype="dashed") +
  geom_smooth(method='lm') +
  facet_grid(~Season) +
  labs(title = "Tree Cover") +
  xlab("Group size") +
  ylab("Model-Averaged Coefficient")
#dev.off()


# collapse hempsen again ?
averaged.results.combined.df2$Hempsen_category2 <- fct_collapse(averaged.results.combined.df2$Hempsen_category, Browser = c("LBr", "SNSBr"), Mixed_Feeder = c("MSMix", "Nrum"), Grazer = "WDGr")

#pdf('Figures/RAI/RAI_tree_dietcategory.pdf', height = 5, width = 7)
ggplot(subset(averaged.results.combined.df2, Covariate == "tree.hansen" & LMH =="yes"), aes(x=Season, y=Estimate, fill = Season)) + 
#  labs(title = "Tree cover by diet") +
  geom_boxplot() +
#  geom_dotplot(binaxis = 'y', stackdir = 'center', position = position_dodge()) +
#  geom_jitter() +
  facet_grid(~Hempsen_category2) +
  ylab("Model-Averaged Coefficient for Tree Cover")
#dev.off()

# try with pansu categories
#pdf('Figures/RAI/RAI_tree_dietcategory.pdf', height = 5, width = 7)
ggplot(subset(averaged.results.combined.df2, Covariate == "tree.hansen" & LMH =="yes"), aes(x=Season, y=Estimate, fill = Season)) + 
#  labs(title = "Tree cover by diet") +
  geom_boxplot() +
#  geom_dotplot(binaxis = 'y', stackdir = 'center', position = position_dodge()) +
#  geom_jitter() +
  facet_grid(~Pansu_guild) +
  ylab("Model-Averaged Coefficient for Tree Cover")
#dev.off()

ggplot(subset(averaged.results.combined.df2, Covariate == "tree.hansen" & LMH =="yes"), aes(x=Season, y=Estimate, fill = Season, label = CommName)) + 
#  labs(title = "Tree cover by diet") +
  geom_dotplot(binaxis = 'y', stackdir = 'center', position = position_dodge()) +
  facet_grid(~Pansu_guild) +
  ylab("Model-Averaged Coefficient for Tree Cover") 
#  geom_text(angle = 45)

se <- function(x) sqrt(var(x)/length(x))

tree_guild_summary <- averaged.results.combined.df2 %>% 
  subset(Covariate == "tree.hansen" & LMH =="yes") %>%
  group_by(Season, Pansu_guild) %>%
  summarise(tree.mean = mean(Estimate),
            tree.se = se(Estimate),
            tree.count = n())

tree_guild_summary$Pansu_guild <- reorder(tree_guild_summary$Pansu_guild, tree_guild_summary$tree.mean)

#pdf('Figures/RAI/tree_cover_foraging_strategy.pdf', useDingbats = F, height = 4, width = 5)
ggplot(tree_guild_summary, aes(x=Pansu_guild, y=tree.mean, col = Season)) + 
  geom_errorbar(aes(ymin = tree.mean - tree.se, ymax = tree.mean + tree.se), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  ylab("Average Coefficient for Tree Cover") +
  xlab("Foraging Strategy") +
  geom_hline(aes(yintercept = 0), linetype="dashed") 
#dev.off()
```

##### Lake
```{r rai urema}
## DISTANCE TO LAKE UREMA
#pdf('Figures/RAI/RAI_lake.pdf', height = 5, width = 7)
ggplot(subset(averaged.results.combined.df2, Covariate == "urema.distance"), aes(x=CommName_Full, y=Estimate, col = Season)) + 
  geom_errorbar(aes(ymin = LowerCI, ymax = UpperCI), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  geom_hline(aes(yintercept = 0), linetype="dashed") +
#  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Lake Urema & RAI", tag = "A)") +
  xlab("Species") +
  ylab("Model-Averaged Coefficient")
#dev.off()

ggplot(subset(averaged.results.combined.df2, Covariate == "urema.distance"), aes(x=CommName_Full, y=Importance, fill = Season)) +
  geom_col(position = position_dodge(width = 1)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Distance to Lake")

#pdf('Figures/RAI/RAI_lake_floodplaincounts.pdf', width = 7, height = 4, useDingbats = F)
ggplot(subset(averaged.results.combined.df2, Covariate == "urema.distance"), aes(x=Floodplain.pct, y=Estimate, col = Season, fill = Season)) + 
#  geom_errorbar(aes(ymin=LowerCI, ymax=UpperCI), width=.1) +
  geom_point() +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
#  geom_hline(aes(yintercept = 0), linetype="dashed") +
  geom_smooth(method='lm') +
  facet_grid( ~ Season) +
#  labs(title = "Urema distance") +
  ylab("Model-Averaged Coefficient for Distance to Lake Urema") +
  xlab("Floodplain Concentration in Dry Season (from Aerial Counts)")
#dev.off()

fit <- lm(Estimate ~ Floodplain.pct, data = subset(averaged.results.combined.df2, Covariate == "urema.distance" & Season == 'dry'))
summary(fit)
fit <- lm(Estimate ~ Floodplain.pct, data = subset(averaged.results.combined.df2, Covariate == "urema.distance" & Season == 'wet'))
summary(fit)

# with fewer Hempsen diet layers - boxplot
ggplot(subset(averaged.results.combined.df2, Covariate == "urema.distance" & LMH =="yes"), aes(x=Season, y=Estimate, fill = Season)) + 
  labs(title = "Lake distance by diet") +
  geom_boxplot() +
  facet_grid(~Hempsen_diet2)


urema_waterdep_summary <- averaged.results.combined.df2 %>% 
  subset(Covariate == "urema.distance" & LMH =="yes") %>%
  group_by(Season, Hempsen_water_dependence) %>%
  summarise(urema.mean = mean(Estimate),
            urema.se = se(Estimate),
            urema.count = n())

urema_waterdep_summary$Hempsen_water_dependence <- reorder(urema_waterdep_summary$Hempsen_water_dependence, urema_waterdep_summary$urema.mean)

#pdf('Figures/RAI/urema_water_dependence.pdf', useDingbats = F, height = 4, width = 5)
ggplot(urema_waterdep_summary, aes(x=Hempsen_water_dependence, y=urema.mean, col = Season)) + 
  geom_errorbar(aes(ymin = urema.mean - urema.se, ymax = urema.mean + urema.se), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  ylab("Average Coefficient for Lake Distance") +
  xlab("Water Dependence") +
  geom_hline(aes(yintercept = 0), linetype="dashed") 
#dev.off()
```

##### Lions
```{r rai lions}
## LIONS
#pdf('Figures/RAI/RAI_lion.pdf', height = 5, width = 7)
ggplot(subset(averaged.results.combined.df2, Covariate == "lion"), aes(x=CommName_Full, y=Estimate, col = Season)) + 
  geom_errorbar(aes(ymin = LowerCI, ymax = UpperCI), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  geom_hline(aes(yintercept = 0), linetype="dashed") +
#  facet_grid(~Hempsen_category, space = "free_x", scales = "free_x") +
  labs(title = "Lions & RAI", tag = "A)") +
  xlab("Species") +
  ylab("Model-Averaged Coefficient")
#dev.off()

ggplot(subset(averaged.results.combined.df2, Covariate == "fire.interval"), aes(x=CommName_Full, y=Importance, fill = Season)) +
  geom_col(position = position_dodge(width = 1)) +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  facet_grid(~Hempsen_category, scales = "free_x", space = "free_x") +
  labs(title = "Fire Frequency")
```


#### Look at the estimates for each species individually
```{r species individually}

common.names.lmh2.nohippo <- rbind(c("Impala", "Hartebeest", "Duiker_red", "Wildebeest", "Sable_antelope", "Waterbuck", "Elephant", "Oribi", "Warthog", "Bushpig", "Reedbuck", "Buffalo", "Duiker_common", "Eland", "Nyala", "Kudu", "Bushbuck"))
common.names.lmh3.nohippo <- rbind(c("Impala", "Hartebeest", "Red duiker", "Common wildebeest", "Sable antelope", "Waterbuck", "Elephant", "Oribi", "Warthog", "Bushpig", "Southern reedbuck", "African buffalo", "Common duiker", "Eland", "Nyala", "Greater kudu", "Bushbuck"))

averaged.results.combined.df2$Covariaterename <- mapvalues(
  averaged.results.combined.df2$Covariate,
  from = levels(averaged.results.combined.df2$Covariate),
  to = c("Intercept", "Fire frequency", "Lion activity", "Pan density", "Poaching", "Distance to river", "Distance to road", "Termite mound density", "Tree cover", "Distance to lake")
)

for (i in 1:length(common.names.lmh2.nohippo)) {
  pdf(paste('Figures/RAI/By species/RAI_', common.names.lmh2.nohippo[[i]], ".pdf", sep=""), height = 5, width = 7)
  species.data.frame <- subset(averaged.results.combined.df2, CommName == common.names.lmh2.nohippo[[i]])
  species.data.frame$Covariaterename <- reorder(species.data.frame$Covariaterename, -species.data.frame$Importance)
    print(ggplot(species.data.frame, aes(x=Covariaterename, y=Estimate, col = Season)) + 
    geom_errorbar(aes(ymin = LowerCI, ymax = UpperCI), width=.1, position = position_dodge(width = .75)) +
    geom_point(position = position_dodge(width = .75)) +
    theme(axis.text.x=element_text(angle=45,hjust=1)) +
    geom_hline(aes(yintercept = 0), linetype="dashed") +
    labs(title = paste("Predictors of RAI for ", common.names.lmh3.nohippo[[i]], sep="")) +
    xlab("Covariate (in order of decreasing importance)") +
    ylab("Model-Averaged Coefficient"))
  dev.off()
}

```

#### Just waterbuck/buffalo vs river/lake
```{r waterbuck buffalo river lake}
averaged.results.combined.df2.koel.syca <- averaged.results.combined.df2[averaged.results.combined.df2$CommName == "Buffalo" | averaged.results.combined.df2$CommName == "Waterbuck",]
averaged.results.combined.df2.koel.syca <- averaged.results.combined.df2.koel.syca[averaged.results.combined.df2.koel.syca$Covariate == "river.distance" | averaged.results.combined.df2.koel.syca$Covariate == "urema.distance",]

#pdf('Figures/RAI/RAI_koelsyca_water.pdf', height = 5, width = 7, useDingbats=F)
ggplot(averaged.results.combined.df2.koel.syca, aes(x=CommName, y=Estimate, col = Season)) + 
  geom_errorbar(aes(ymin = LowerCI, ymax = UpperCI), width=.1, position = position_dodge(width = .75)) +
  geom_point(position = position_dodge(width = .75)) +
  geom_hline(aes(yintercept = 0), linetype="dashed") +
  facet_grid(~Covariate, space = "free_x", scales = "free_x") +
#  labs(title = "Fire frequency & RAI", tag = "A)") +
  xlab("Species") +
  ylab("Model-Averaged Coefficient")
#dev.off()

```



#### Quick explore of a bunch of trait effects on different covariates
```{r effects of traits on covariates}
# relating to diet

########################################
# Hempsen_category
########################################

#pdf('Figures/RAI/Allestimates_vs_hempsencategory.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=Hempsen_category, y=Estimate, fill = Season)) + 
  geom_boxplot() +
  labs(title = "Hempsen category") +
  xlab("Hempsen category") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_hempsencategory_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=Hempsen_category, y=Estimate)) + 
  geom_boxplot() +
  labs(title = "Hempsen category") +
  xlab("Hempsen category") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_hempsencategory_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=Hempsen_category, y=Estimate)) + 
  geom_boxplot() +
  labs(title = "Hempsen category") +
  xlab("Hempsen category") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()


########################################
# Pansu_pop_niche_width
########################################

#pdf('Figures/RAI/Allestimates_vs_nichewidth.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=Pansu_pop_niche_width, y=Estimate, col = Season, fill = Season)) + 
  geom_point() +
  geom_smooth(method='lm') +
  labs(title = "Niche width") +
  xlab("Niche Width") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_nichewidth_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=Pansu_pop_niche_width, y=Estimate)) + 
  geom_point() +
  geom_smooth(method='lm') +
  labs(title = "Niche width") +
  xlab("Niche Width") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_nichewidth_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=Pansu_pop_niche_width, y=Estimate)) + 
  geom_point() +
  geom_smooth(method='lm') +
  labs(title = "Niche width") +
  xlab("Niche Width") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

########################################
# Pansu_indiv_niche_breadth
########################################

#pdf('Figures/RAI/Allestimates_vs_nichebreadthindiv.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=Pansu_indiv_niche_breadth, y=Estimate, col = Season, fill = Season)) + 
  geom_point() +
  geom_smooth(method='lm') +
  labs(title = "Niche breadth (individual)") +
  xlab("Niche Breadth (individual)") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_nichebreadthindiv_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=Pansu_indiv_niche_breadth, y=Estimate)) + 
  geom_point() +
  geom_smooth(method='lm') +
  labs(title = "Niche breadth (individual)") +
  xlab("Niche Breadth (individual)") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()


#pdf('Figures/RAI/Allestimates_vs_nichebreadthindiv_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=Pansu_indiv_niche_breadth, y=Estimate)) + 
  geom_point() +
  geom_smooth(method='lm') +
  labs(title = "Niche breadth (individual)") +
  xlab("Niche Breadth (individual)") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

########################################
# Hempsen_diet2
########################################

#pdf('Figures/RAI/Allestimates_vs_dietcategory.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=Hempsen_diet2, y=Estimate, fill = Season)) + 
  geom_boxplot() +
  labs(title = "Diet category") +
  xlab("Diet category") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_dietcategory_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=Hempsen_diet2, y=Estimate)) + 
  geom_boxplot() +
  labs(title = "Diet category") +
  xlab("Diet category") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_dietcategory_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=Hempsen_diet2, y=Estimate)) + 
  geom_boxplot() +
  labs(title = "Diet category") +
  xlab("Diet category") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()


########################################
# Pansu_percent_gras_RRA
########################################

#pdf('Figures/RAI/Allestimates_vs_grassindiet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=Pansu_percent_gras_RRA, y=Estimate, col = Season, fill = Season)) + 
  geom_point() +
  geom_smooth(method='lm') +
  labs(title = "% Grass in Diet") +
  xlab("% Grass in Diet") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_grassindiet_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=Pansu_percent_gras_RRA, y=Estimate)) + 
  geom_point() +
  geom_smooth(method='lm') +
  labs(title = "% Grass in Diet") +
  xlab("% Grass in Diet") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_grassindiet_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=Pansu_percent_gras_RRA, y=Estimate)) + 
  geom_point() +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  geom_smooth(method='lm') +
  labs(title = "% Grass in Diet") +
  xlab("% Grass in Diet") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

# relating to water stuff

########################################
# Floodplain.pct
########################################

#pdf('Figures/RAI/Allestimates_vs_floodplainpct.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=Floodplain.pct, y=Estimate, col = Season, fill = Season)) + 
  geom_point() +
  geom_smooth(method='lm') +
  labs(title = "% Floodplain") +
  xlab("% Floodplain") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_floodplainpct_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=Floodplain.pct, y=Estimate)) + 
  geom_point() +
  geom_smooth(method='lm') +
  labs(title = "% Floodplain") +
  xlab("% Floodplain") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_floodplainpct_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=Floodplain.pct, y=Estimate)) + 
  geom_point() +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  geom_smooth(method='lm') +
  labs(title = "% Floodplain") +
  xlab("% Floodplain") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

########################################
# Hempsen_water_dependence
########################################

#pdf('Figures/RAI/Allestimates_vs_waterdependence.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=Hempsen_water_dependence, y=Estimate, fill = Season)) + 
  geom_boxplot() +
  labs(title = "Water dependence") +
  xlab("Water dependence") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_waterdependence_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=Hempsen_water_dependence, y=Estimate)) + 
  geom_boxplot() +
  labs(title = "Water dependence") +
  xlab("Water dependence") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_waterdependence_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=Hempsen_water_dependence, y=Estimate)) + 
  geom_boxplot() +
  labs(title = "Water dependence") +
  xlab("Water dependence") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

# as numeric
#pdf('Figures/RAI/Allestimates_vs_waterdependence_numeric.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=Hempsen_water_dependence_numbers, y=Estimate, col = Season, fill = Season)) + 
  geom_jitter() +
  geom_smooth(method='lm') +
  labs(title = "Water dependence index") +
  xlab("Water dependence index") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free') 
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_waterdependence_numeric_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=Hempsen_water_dependence_numbers, y=Estimate)) + 
  geom_jitter() +
  geom_smooth(method='lm') +
  labs(title = "Water dependence index") +
  xlab("Water dependence index") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free') 
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_waterdependence_numeric_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=Hempsen_water_dependence_numbers, y=Estimate)) + 
  geom_jitter() +
  geom_smooth(method='lm') +
  labs(title = "Water dependence index") +
  xlab("Water dependence index") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free') 
#dev.off()

# sociality

########################################
# Hempsen_herd_size
########################################

#pdf('Figures/RAI/Allestimates_vs_herdsize.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=Hempsen_herd_size, y=Estimate, fill = Season)) + 
  geom_boxplot() +
  labs(title = "Herd size") +
  xlab("Herd size") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_herdsize_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=Hempsen_herd_size, y=Estimate)) + 
  geom_boxplot() +
  labs(title = "Herd size") +
  xlab("Herd size") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_herdsize_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=Hempsen_herd_size, y=Estimate)) + 
  geom_boxplot() +
  labs(title = "Herd size") +
  xlab("Herd size") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

# as numeric
#pdf('Figures/RAI/Allestimates_vs_herdsize_numeric.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=Hempsen_herd_size_number, y=Estimate, col = Season, fill = Season)) + 
  geom_jitter() +
  geom_smooth(method='lm') +
  labs(title = "Herd size index") +
  xlab("Herd size index") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free') 
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_herdsize_numeric_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=Hempsen_herd_size_number, y=Estimate)) + 
  geom_jitter() +
  geom_smooth(method='lm') +
  labs(title = "Herd size index") +
  xlab("Herd size index") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free') 
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_herdsize_numeric_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=Hempsen_herd_size_number, y=Estimate)) + 
  geom_jitter() +
  geom_smooth(method='lm') +
  labs(title = "Herd size index") +
  xlab("Herd size index") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free') 
#dev.off()



########################################
# Sociality
########################################


#pdf('Figures/RAI/Allestimates_vs_sociality.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=Sociality, y=Estimate, fill = Season)) + 
  geom_boxplot() +
  labs(title = "Sociality") +
  xlab("Sociality") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_sociality_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=Sociality, y=Estimate)) + 
  geom_boxplot() +
  labs(title = "Sociality") +
  xlab("Sociality") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_sociality_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=Sociality, y=Estimate)) + 
  geom_boxplot() +
  labs(title = "Sociality") +
  xlab("Sociality") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

# size

########################################
# Weight
########################################

#pdf('Figures/RAI/Allestimates_vs_weight.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=log(Weight), y=Estimate, col = Season, fill = Season)) + 
  geom_point() +
  geom_smooth(method='lm') +
  labs(title = "Weight") +
  xlab("Weight") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_weight_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=log(Weight), y=Estimate)) + 
  geom_point() +
  geom_smooth(method='lm') +
  labs(title = "Weight") +
  xlab("Weight") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_weight_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=log(Weight), y=Estimate)) + 
  geom_point() +
  theme(axis.text.x=element_text(angle=45,hjust=1)) +
  geom_smooth(method='lm') +
  labs(title = "Weight") +
  xlab("Weight") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

########################################
# Mass_category
########################################

#pdf('Figures/RAI/Allestimates_vs_Mass_category.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2), aes(x=Mass_category, y=Estimate, fill = Season)) + 
  geom_boxplot() +
  labs(title = "Mass_category") +
  xlab("Mass_category") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_Mass_category_dry.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'dry'), aes(x=Mass_category, y=Estimate)) + 
  geom_boxplot() +
  labs(title = "Mass_category") +
  xlab("Mass_category") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

#pdf('Figures/RAI/Allestimates_vs_Mass_category_wet.pdf', height = 9, width = 12)
ggplot(subset(averaged.results.combined.df2, Season == 'wet'), aes(x=Mass_category, y=Estimate)) + 
  geom_boxplot() +
  labs(title = "Mass_category") +
  xlab("Mass_category") +
  ylab("Model-Averaged Coefficient") +
  facet_wrap(~Covariate, scales = 'free')
#dev.off()

```



## Spatially map the GLM RAI outputs

Read in the coarse rasters (for model projection) and stack together. I found this code that allows you to load multiple rasters in at the same time and automatically stack them: https://gis.stackexchange.com/questions/136231/importing-several-geotiff-files-into-r I haven't actually run this, though.
(However, I'm getting an error that I cannot create a raster file. I don't really have patience to troubleshoot so am importing them separately.)
```{r coarse raster stack}
# coarse.stack <- do.call(stack, lapply(list.files(path = "./GIS/Rasters for stacking/Normalized and masked and coarse rasters"), raster))

boundary.dist.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/boundary.dist.norm.coarse.tif")
fire.crop.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/fire.crop.res.norm.coarse.tif")
fire2015.crop.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/fire2015.crop.res.norm.coarse.tif")
fire2016.crop.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/fire2015.crop.res.norm.coarse.tif")
fire2017.crop.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/fire2015.crop.res.norm.coarse.tif")
pans.crop.100m.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/pans.crop.100m.res.norm.coarse.tif")
pans.crop.250m.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/pans.crop.250m.res.norm.coarse.tif")
pans.crop.500m.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/pans.crop.500m.res.norm.coarse.tif")
pans.crop.1km.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/pans.crop.1km.res.norm.coarse.tif")
pans.dist.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/pans.dist.norm.coarse.tif")
poaching.all.raster.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/poaching.all.raster.res.norm.coarse.tif")
poaching.high.raster.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/poaching.high.raster.res.norm.coarse.tif")
rivers.dist.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/rivers.dist.norm.coarse.tif")
road.dist.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/road.dist.norm.coarse.tif")
roadsmajor.dist.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/roadsmajor.dist.norm.coarse.tif")
termites.crop.100m.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/termites.crop.100m.norm.coarse.tif")
termites.crop.250m.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/termites.crop.250m.norm.coarse.tif")
termites.crop.500m.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/termites.crop.500m.norm.coarse.tif")
termites.crop.1km.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/termites.crop.1km.norm.coarse.tif")
termites.crop.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/termites.crop.norm.coarse.tif")
tree.crop.100m.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/tree.crop.100m.res.norm.coarse.tif")
tree.crop.250m.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/tree.crop.250m.res.norm.coarse.tif")
tree.crop.500m.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/tree.crop.500m.res.norm.coarse.tif")
tree.crop.1km.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/tree.crop.1km.res.norm.coarse.tif")
tree.crop.res.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/tree.crop.res.norm.coarse.tif")
urema.dist.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/urema.dist.norm.coarse.tif")
lion.wet <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/lion.wet.tif")
lion.dry <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/lion.dry.tif")
tree.hansen <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/tree.hansen.crop.res.norm.coarse.tif")
settlement.distance <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/settlement.dist.norm.coarse.tif")
panscon.250m <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/panscon.250.norm.coarse.tif")
poaching.3levels.mask.norm.coarse <- raster("GIS/Rasters for stacking/Normalized and masked and coarse rasters/poaching.3levels.mask.norm.coarse.tif")


raster.stack <- raster::stack(boundary.dist.norm.coarse, fire.crop.res.norm.coarse,
                              pans.crop.100m.res.norm.coarse, pans.crop.250m.res.norm.coarse, pans.crop.500m.res.norm.coarse, 
                              pans.crop.1km.res.norm.coarse, pans.dist.norm.coarse, poaching.all.raster.res.norm.coarse, 
                              poaching.high.raster.res.norm.coarse, rivers.dist.norm.coarse, road.dist.norm.coarse, roadsmajor.dist.norm.coarse,
                              termites.crop.100m.norm.coarse, termites.crop.250m.norm.coarse, termites.crop.500m.norm.coarse,
                              termites.crop.1km.norm.coarse, termites.crop.norm.coarse, tree.crop.100m.res.norm.coarse, 
                              tree.crop.250m.res.norm.coarse, tree.crop.500m.res.norm.coarse, tree.crop.1km.res.norm.coarse, tree.crop.res.norm.coarse,
                              urema.dist.norm.coarse, lion.wet, lion.dry, tree.hansen, settlement.distance, panscon.250m)

# make sure the names match the names of the covariates in the output; they probably won't, and will need changing. Also this order will have to change to match the order in which the rasters are read? maybe? (not sure how period is incorporated into alphabetical order) and maybe there are some rasters in the folder that are not listed here
names(raster.stack) <- c("boundary.distance", 
                         "fire.interval", 
                         "pans.100m", "pans.250m", "pans.500m", "pans.1km", "pan.distance", 
                         "poaching.all", "poaching.high",
                         "river.distance", 
                         "road.distance", "road.major.distance", 
                         "termite.count.100m", "termites.250m", "termites.500m", "termites.1km", "termites",
                         "tree.100m", "tree.250m", "tree.500m", "tree.1km", "tree", 
                         "urema.distance", "lion.wet", "lion.dry", "tree.hansen", "settlement.distance", 
                         "panscon.250m")
```

Here's a way to plot the outputs of the best models from those determined above using glmulti (with spatial covariates only). 
```{r plot all glm output dry, eval = F}
# write function
#plot.best <- function(glmulti.output, speciesname, rasterstack, colorramp = brewer.pal(n = 9, name = "Blues")){
#  best.model <- glmulti.output@objects[[1]]
#  prediction <- raster::predict(rasterstack, best.model, type = "response")
#  plot(prediction, main = speciesname, col = colorramp)
#}

# plot for all species - this takes a while to run! 
#for (i in 1:38) {
#  plot.best(model.outputs.dry[[i]], common.names[[i]], raster.stack)
#}

# here's another approach, which first makes predictions, then stores them for later plotting - probably a better one
predict.best <- function(glmulti.output, rasterstack) {
  best.model <- glmulti.output@objects[[1]]
  prediction <- raster::predict(rasterstack, best.model, type = "response")
  return(prediction)
}

# predictions for best model for all species - takes a while to run! - store in a new list
model.predictions.dry.combined <- list()
for (i in c(1:4, 6:17)) {
  model.predictions.dry.combined[[i]] <- predict.best(model.outputs.dry.combined[[i]], raster.stack)
  
}

# and plot them
color.ramp.reds = brewer.pal(n = 9, name = "Reds")
for (i in c(1:4, 6:17)) {
  pdf(paste('Figures/RAI_maps/', common.names.lmh[[i]], '.dry.pdf', sep=""))
  plot(model.predictions.dry.combined[[i]], main = common.names.lmh[[i]], col = color.ramp.reds)
  dev.off()
}
```

for wet season
```{r plot all glm output wet, eval = F}
# predictions for best model for all species - takes a while to run! - store in a new list
model.predictions.wet.combined <- list()
for (i in c(1:17)) {
  model.predictions.wet.combined[[i]] <- predict.best(model.outputs.wet.combined[[i]], raster.stack)
  
}

# and plot them
color.ramp.blues = brewer.pal(n = 9, name = "Blues")
for (i in c(1:17)) {
  pdf(paste('Figures/RAI_maps/', common.names.lmh[[i]], '.wet.pdf', sep=""))
  plot(model.predictions.wet.combined[[i]], main = common.names.lmh[[i]], col = color.ramp.blues)
  dev.off()
}


# plot both
for (i in c(1:12, 15:38)) {
  par(mfrow=c(2,1))
  plot(model.predictions.dry[[i]], main = paste(common.names[[i]], "Dry"), col = color.ramp.reds)
  plot(model.predictions.wet4mo[[i]], main = paste(common.names[[i]], "Wet"), col = color.ramp.blues)
}
```


## Spatial patterns of RAI across seasons, visualized
```{r hexes}
# load in camera polygons
hexes <- readOGR("~/Dropbox/projects/GORONGOSA2/Camera Trap Grid/Github Repos/gorongosa-camera-traps/gis/Camera layers", "CameraGridHexes")
```


```{r spatial mapping, warning = F, message = F, echo = F}
# plot hexagons alone (store in object 'map')
map <- ggplot() + 
  geom_polygon(data = hexes, aes(x = long, y = lat, group = group), color = "black", fill=NA)
# map   # (to plot)

# dry waterbuck - size of points corresponds to RAI dry season
map + geom_point(aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI.dry.year1),
                  data = rai.koel, colour = 'blue') + 
  scale_size_continuous(range = c(1, 9), 
                        breaks = c(0, 1, 2))
map + geom_point(aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI.dry.year2),
                  data = rai.koel, colour = 'blue') + 
  scale_size_continuous(range = c(1, 9), 
                        breaks = c(0, 1, 2))

# wet waterbuck - size of points corresponds to RAI wet season
map + geom_point(aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI.wet.year1),
                  data = rai.koel, colour = 'red') + 
  scale_size_continuous(range = c(1, 13), 
                        breaks = c(0, 1, 2, 3)) 

map + geom_point(aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI.wet.year2),
                  data = rai.koel, colour = 'red') + 
  scale_size_continuous(range = c(1, 13), 
                        breaks = c(0, 1, 2, 3)) 

# try animating through all species - not actually that interesting, it flips through them too quickly
#p <- ggplot(data = rai.long.2seasons, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) +
#  geom_point() +
#  facet_grid(Season ~ .) +
#  labs(title = 'Species: {closest_state}') +
#  transition_states(CommName, transition_length = 2, state_length = 5) +
#  ease_aes('linear')
#p
```

Currently don't have the monthly RAI imported here... so just not running these chunks

Monthly spatial mappings
```{r month import, eval = F, warning = F}
# waterbuck only - animating through all months (with hexagons)
p <- ggplot() +
  geom_point(data = rai.monthly.koel, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) +
  labs(title = 'Month: {closest_state}') +
  transition_states(Month, transition_length = 1, state_length = 2) +
  ease_aes('linear') + 
  geom_polygon(data = hexes, aes(x = long, y = lat, group = group), color = "black", fill=NA)
p
```

```{r waterbuck and reedbuck, eval = F, echo = F}
# combine waterbuck and reedbuck
koel.rere <- rbind(rai.monthly.koel, rai.monthly.rere)

# waterbuck and reedbuck together - just to see
# doesn't actually work that well because the RAI scale is the same for both facets
p <- ggplot() +
  geom_point(data = koel.rere, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) +
  facet_grid(CommName ~ .) +
  labs(title = 'Month: {closest_state}') +
  transition_states(Month, transition_length = 1, state_length = 2) +
  ease_aes('linear') + 
  geom_polygon(data = hexes, aes(x = long, y = lat, group = group), color = "black", fill=NA)
```


### Herbivores

#### Waterbuck maps
```{r waterbuck maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.koel, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "KOEL"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Reedbuck maps
```{r reedbuck maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.rere, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "RERE"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Impala maps
```{r impala maps, eval = F}
# by month
ggplot(data = rai.monthly.aeme, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "AEME"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Warthog maps
```{r warthog maps, eval = F,  warning = F}
# by month
ggplot(data = rai.monthly.phaf, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "PHAF"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Oribi maps
```{r oribi maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.ouou, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "OUOU"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Bushbuck maps
```{r bushbuck maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.trsy, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "TRSY"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Nyala maps
```{r nyala maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.tran, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "TRAN"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Kudu maps
```{r kudu maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.trst, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "TRST"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Sable maps
```{r sable maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.hini, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "HINI"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Elephant maps
```{r elephant maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.loaf, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "LOAF"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Buffalo maps
```{r buffalo maps, eval = F,  warning = F}
# by month
ggplot(data = rai.monthly.syca, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "SYCA"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Hartebeest maps
```{r hartebeest maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.albu, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "ALBU"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Wildebeest maps
```{r wildebeest maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.cota, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "COTA"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r common duiker maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.sygr, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "SYGR"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r red duiker maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.cena, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "CENA"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r eland maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.taor, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "TAOR"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r hippo maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.hiam, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "HIAM"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

### Primates

#### Baboon maps
```{r baboon maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.pacy, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "PACY"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

####8/23/19 - doing again for the baboon researchers

```{r baboon maps take 2, eval = F}
# baboon
pdf('Figures/Baboon_RAI_by_camera.pdf', height = 10, width = 12, useDingbats = F)
ggplot(data = subset(rai.long, SppCode == "PACY"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point(col = "red") + facet_wrap(Year ~ Season) + geom_text(size = 3,col = "black", aes(label=StudySite),hjust=.5, vjust=-.5) + ggtitle('Baboon Activity')
dev.off()

# elephant
pdf('Figures/Elephant_RAI_by_camera.pdf', height = 10, width = 12, useDingbats = F)
ggplot(data = subset(rai.long, SppCode == "LOAF"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point(col = "red") + facet_wrap(Year ~ Season) + geom_text(size = 3,col = "black", aes(label=StudySite),hjust=.5, vjust=-.5) + ggtitle('Elephant Activity')
dev.off()

```


#### Vervet maps
```{r vervet maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.chpy, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "CHPY"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r samango maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.ceal, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "CEAL"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r bushbaby maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.otcr, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "OTCR"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

### Carnivores

#### Lion maps
```{r lion maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.pale, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "PALE"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Civet maps
```{r civet maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.cici, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "CICI"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Genet maps
```{r genet maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.gege, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "GEGE"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Honey badger maps
```{r honey badger maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.meca, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "MECA"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

#### Porcupine maps
```{r porcupine maps, eval = F, warning = F}
# by month
ggplot(data = rai.monthly.hyaf, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "HYAF"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```


```{r aardvark maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.oraf, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "ORAF"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```


```{r hare maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.lemi, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "LEMI"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r mongoose banded maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.mumu, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "MUMU"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r mongoose bushy tailed maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.bdcr, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "BDCR"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```


```{r mongoose dwarf maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.hepa, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "HEPA"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r mongoose large grey maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.heic, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "HEIC"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r mongoose marsh maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.atpa, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "ATPA"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r mongoose slender maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.gasa, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "GASA"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r mongoose white tailed maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.ical, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "ICAL"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```

```{r pangolin maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.mate, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "MATE"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```


```{r serval maps, eval = F, echo = F}
# by month
ggplot(data = rai.monthly.lese, aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(~ Month)

# by season
ggplot(data = subset(rai.long.2seasons, SppCode == "LESE"), aes(x=Longitude.UTM, y=Latitude.UTM, size = RAI)) + geom_point() + facet_wrap(Season ~.)
```


## Plot waterbuck annually

```{r waterbuck manual}
# plot rai
waterbuck.rai <- data.frame("SeasonYear" = c("Year 1 Dry", "Year 1 Wet", "Year 2 Dry", "Year 2 Wet"), "Mean" = c(0.3834333876, 0.6810523644, 0.5306298170, 0.9505277955), "SE" = c(0.0723143268, 0.1273064022, 0.1250232264, 0.1757500351), "Season" = c("Dry", "Wet", "Dry", "Wet"), Year = c(1,1,2,2))

pdf('Figures/WaterbuckRAI_by_year.pdf', height = 4, width = 6, useDingbats = F)
ggplot(data = waterbuck.rai, aes(x = SeasonYear, y = Mean, col = Season)) +
  geom_point() +
  geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE), width=.1) 
dev.off()

# to manually map waterbuck - multiply estimate by the coarse raster value, then multiply by importance to weigh it

# map waterbuck in dry season

# THIS IS STANDARDIZED RAI!!!

waterbuck_dry_raster_stand <- -0.031303342 + # intercept
  -0.46774028 * urema.dist.norm.coarse * 1.00 +
  -0.168621572 * termites.crop.100m.norm.coarse * 1.00 + 
  -0.360153251 * rivers.dist.norm.coarse * 1.00 +
  -0.042107985 * roadsmajor.dist.norm.coarse * 0.38 +
  0.016165048 * tree.hansen * .185 +
  -0.021471523 * panscon.250m * .173 +
  0.00741818 * fire.crop.res.norm.coarse * 0.148436424 +
  -0.003604391 * lion.dry * 0.081061483 +
  0.000327853 * poaching.3levels.mask.norm.coarse * 0.07255109

# map waterbuck in wet season
waterbuck_wet_raster_stand <- -0.07469842 + # intercept 
  -0.535804906 * urema.dist.norm.coarse * 1.00 +
  0.060350282 * lion.wet * 0.431720391 +
  -0.038155006 * tree.hansen * 0.293387597 +
  -0.03897222 * rivers.dist.norm.coarse * 0.291704715 +
  -0.028453834 * roadsmajor.dist.norm.coarse * 0.255419957 +
  0.019046324 * poaching.3levels.mask.norm.coarse * 0.202132353 +
  -0.021384824 * panscon.250m * 0.144833408 +
  -0.006998094 * termites.crop.100m.norm.coarse * 0.10819665 +
  0.000422863 * fire.crop.res.norm.coarse * 0.024592361


# run non-standardized models so we can compare waterbuck seasonally
### DRY
  data.to.use <- rai.long.dry[rai.long.dry$SppCode == "KOEL", ]
  data.to.use <- dplyr::select(data.to.use, RAI, StudySite, poaching, poaching.high, fire.interval, road.major.distance, urema.distance, tree.hansen, termite.count.100m, panscon.250m, lion.dry, pan.distance, settlement.distance, river.distance, panscon.offflood.250) # select all variables to use; this way, we can use complete.cases and only remove lines with NA RAI
  data.to.use <- data.to.use[complete.cases(data.to.use),] # there is an error in lme if there are NAs, but then if I set na.action = na.omit in the lme model then there is an error in the dredging, so this is the way it has to be
  model.outputs.waterbuck.dry <- lme(RAI ~ poaching + fire.interval + river.distance +
                                           road.major.distance + urema.distance + tree.hansen + 
                                           termite.count.100m + panscon.250m + lion.dry, 
                                       data = data.to.use,
                                       random = ~ 1|StudySite, 
                                       method = "ML",
                                       keep.data = TRUE)
  
  fit.dredge <- dredge(model.outputs.waterbuck.dry, rank = "AIC")
  (attr(fit.dredge, "rank.call"))
  # Get the models (fitted by REML, as in the global model)
  fmList <- get.models(fit.dredge, subset = delta < 2)
  # Because the models originate from 'dredge(..., rank = AICc, REML = FALSE)',
  # the default weights in 'model.avg' are ML based:
  averaged.results.waterbuck.dry <- model.avg(fmList)
  
  estimates <- as.data.frame(averaged.results.waterbuck.dry[[2]])
  
  # take only full estimates, not subset estimates
  estimates <- estimates[1,]
  # move variable names into first column
  estimates <- rbind(Factor = names(estimates), estimates)
  # transpose, keep names
  estimates <- as.data.frame(t(estimates), row.names=F)
  # change names
  names(estimates) <- c("Covariate", "Estimate")
  
  # now wrangle confidence intervals
  confidence.intervals <- confint(averaged.results.waterbuck.dry)
  # move variable names into first column
  row.names.placeholder <- rownames(confidence.intervals)
  rownames(confidence.intervals) <- NULL
  confidence.intervals <- as.data.frame(cbind(row.names.placeholder,confidence.intervals))
  names(confidence.intervals) <- c("Covariate", "LowerCI", "UpperCI")
  averaged.results.waterbuck.dry <- cbind(estimates, confidence.intervals[,2:3])
  averaged.results.waterbuck.dry$CommName <- "Waterbuck"
  
  # and get relative importance values
  importance.values <- as.data.frame(importance(fmList))
  row.names.placeholder <- rownames(importance.values)
  importance.values <- as.data.frame(cbind(row.names.placeholder,importance.values))
  names(importance.values) <- c("Covariate", "Importance")
  averaged.results.waterbuck.dry <- left_join(averaged.results.waterbuck.dry, importance.values)
  
averaged.results.waterbuck.dry$Season <- "dry"

## WET SEASON

  data.to.use <- rai.long.wet[rai.long.wet$SppCode == "KOEL", ]
  data.to.use <- dplyr::select(data.to.use, RAI, StudySite, poaching, poaching.high, fire.interval, road.major.distance, urema.distance, tree.hansen, termite.count.100m, panscon.250m, lion.wet, pan.distance, settlement.distance, river.distance, panscon.offflood.250) # select all variables to use; this way, we can use complete.cases and only remove lines with NA RAI
  data.to.use <- data.to.use[complete.cases(data.to.use),] # there is an error in lme if there are NAs, but then if I set na.action = na.omit in the lme model then there is an error in the dredging, so this is the way it has to be
  model.outputs.waterbuck.wet <- lme(RAI ~ poaching + fire.interval + river.distance +
                                           road.major.distance + urema.distance + tree.hansen + 
                                           termite.count.100m + panscon.250m + lion.wet, 
                                       data = data.to.use,
                                       random = ~ 1|StudySite, 
                                       method = "ML",
                                       keep.data = TRUE)
  
  fit.dredge <- dredge(model.outputs.waterbuck.wet, rank = "AIC")
  (attr(fit.dredge, "rank.call"))
  # Get the models (fitted by REML, as in the global model)
  fmList <- get.models(fit.dredge, subset = delta < 2)
  # Because the models originate from 'dredge(..., rank = AICc, REML = FALSE)',
  # the default weights in 'model.avg' are ML based:
  averaged.results.waterbuck.wet <- model.avg(fmList)
  
  estimates <- as.data.frame(averaged.results.waterbuck.wet[[2]])
  
  # take only full estimates, not subset estimates
  estimates <- estimates[1,]
  # move variable names into first column
  estimates <- rbind(Factor = names(estimates), estimates)
  # transpose, keep names
  estimates <- as.data.frame(t(estimates), row.names=F)
  # change names
  names(estimates) <- c("Covariate", "Estimate")
  
  # now wrangle confidence intervals
  confidence.intervals <- confint(averaged.results.waterbuck.wet)
  # move variable names into first column
  row.names.placeholder <- rownames(confidence.intervals)
  rownames(confidence.intervals) <- NULL
  confidence.intervals <- as.data.frame(cbind(row.names.placeholder,confidence.intervals))
  names(confidence.intervals) <- c("Covariate", "LowerCI", "UpperCI")
  averaged.results.waterbuck.wet <- cbind(estimates, confidence.intervals[,2:3])
  averaged.results.waterbuck.wet$CommName <- "Waterbuck"
  
  # and get relative importance values
  importance.values <- as.data.frame(importance(fmList))
  row.names.placeholder <- rownames(importance.values)
  importance.values <- as.data.frame(cbind(row.names.placeholder,importance.values))
  names(importance.values) <- c("Covariate", "Importance")
  averaged.results.waterbuck.wet <- left_join(averaged.results.waterbuck.wet, importance.values)
  
averaged.results.waterbuck.wet$Season <- "wet"


averaged.results.waterbuck.combined.df <- rbind(averaged.results.waterbuck.dry, averaged.results.waterbuck.wet)
#write.csv(averaged.results.waterbuck.combined.df, "Results/RAI/averaged.results.waterbuck.nonstandard.csv", row.names = F)

# now plot results of non-standard model
waterbuck_dry_raster <- 0.424808684 + # intercept
  -0.249766507 * rivers.dist.norm.coarse +
#  -0.116939165 * termites.crop.100m.norm.coarse +
  -0.324378181 * urema.dist.norm.coarse +
  -0.029201916 * roadsmajor.dist.norm.coarse * 0.380259571 +
  0.011210473 * tree.hansen * 0.184977174 +
  -0.014890515 * panscon.250m * 0.172967011 +
  -0.002499648 * lion.dry * 0.081061483 +
  0.005144513 * fire.crop.res.norm.coarse * 0.148436424 +
  0.000227366 * poaching.3levels.mask.norm.coarse * 0.07255109

waterbuck_wet_raster <- 0.712036175 +
  -0.038849446 * rivers.dist.norm.coarse * 0.291704715 +
  -0.534116958 * urema.dist.norm.coarse * 1 +
  0.06016016 * lion.wet * 0.431720391 +
  -0.028364196 * roadsmajor.dist.norm.coarse * 0.255419957 +
  -0.038034807 * tree.hansen * 0.293387597 +
  0.018986322 * poaching.3levels.mask.norm.coarse * 0.202132353 +
  -0.021317455 * panscon.250m * 0.144833408 + 
#  -0.006976048 * termites.crop.100m.norm.coarse * 0.10819665 +
  0.000421531 * fire.crop.res.norm.coarse * 0.024592361

waterbuck_wet_minus_dry <- waterbuck_wet_raster - waterbuck_dry_raster

#writeRaster(waterbuck_dry_raster, 'waterbuck_dry_raster.tif', format="GTiff", overwrite=TRUE, options=c("INTERLEAVE=BAND","COMPRESS=LZW"))
#writeRaster(waterbuck_wet_raster, 'waterbuck_wet_raster.tif', format="GTiff", overwrite=TRUE, options=c("INTERLEAVE=BAND","COMPRESS=LZW"))
#writeRaster(waterbuck_wet_minus_dry, 'waterbuck_wet_minus_dry.tif', format="GTiff", overwrite=TRUE, options=c("INTERLEAVE=BAND","COMPRESS=LZW"))



```


## Plot Tragelaphines annually

#### Bushbuck
```{r bushbuck manual}
### DRY
  data.to.use <- rai.long.dry[rai.long.dry$SppCode == "TRSY", ]
  data.to.use <- dplyr::select(data.to.use, RAI, StudySite, poaching, poaching.high, fire.interval, road.major.distance, urema.distance, tree.hansen, termite.count.100m, panscon.250m, lion.dry, pan.distance, settlement.distance, river.distance, panscon.offflood.250) # select all variables to use; this way, we can use complete.cases and only remove lines with NA RAI
  data.to.use <- data.to.use[complete.cases(data.to.use),] # there is an error in lme if there are NAs, but then if I set na.action = na.omit in the lme model then there is an error in the dredging, so this is the way it has to be
  model.outputs.bushbuck.dry <- lme(RAI ~ poaching + fire.interval + river.distance +
                                           road.major.distance + urema.distance + tree.hansen + 
                                           termite.count.100m + panscon.250m + lion.dry, 
                                       data = data.to.use,
                                       random = ~ 1|StudySite, 
                                       method = "ML",
                                       keep.data = TRUE)
  
  fit.dredge <- dredge(model.outputs.bushbuck.dry, rank = "AIC")
  (attr(fit.dredge, "rank.call"))
  # Get the models (fitted by REML, as in the global model)
  fmList <- get.models(fit.dredge, subset = delta < 2)
  # Because the models originate from 'dredge(..., rank = AICc, REML = FALSE)',
  # the default weights in 'model.avg' are ML based:
  averaged.results.bushbuck.dry <- model.avg(fmList)
  
  estimates <- as.data.frame(averaged.results.bushbuck.dry[[2]])
  
  # take only full estimates, not subset estimates
  estimates <- estimates[1,]
  # move variable names into first column
  estimates <- rbind(Factor = names(estimates), estimates)
  # transpose, keep names
  estimates <- as.data.frame(t(estimates), row.names=F)
  # change names
  names(estimates) <- c("Covariate", "Estimate")
  
  # now wrangle confidence intervals
  confidence.intervals <- confint(averaged.results.bushbuck.dry)
  # move variable names into first column
  row.names.placeholder <- rownames(confidence.intervals)
  rownames(confidence.intervals) <- NULL
  confidence.intervals <- as.data.frame(cbind(row.names.placeholder,confidence.intervals))
  names(confidence.intervals) <- c("Covariate", "LowerCI", "UpperCI")
  averaged.results.bushbuck.dry <- cbind(estimates, confidence.intervals[,2:3])
  averaged.results.bushbuck.dry$CommName <- "Bushbuck"
  
  # and get relative importance values
  importance.values <- as.data.frame(importance(fmList))
  row.names.placeholder <- rownames(importance.values)
  importance.values <- as.data.frame(cbind(row.names.placeholder,importance.values))
  names(importance.values) <- c("Covariate", "Importance")
  averaged.results.bushbuck.dry <- left_join(averaged.results.bushbuck.dry, importance.values)
  
averaged.results.bushbuck.dry$Season <- "dry"

## WET SEASON

  data.to.use <- rai.long.wet[rai.long.wet$SppCode == "TRSY", ]
  data.to.use <- dplyr::select(data.to.use, RAI, StudySite, poaching, poaching.high, fire.interval, road.major.distance, urema.distance, tree.hansen, termite.count.100m, panscon.250m, lion.wet, pan.distance, settlement.distance, river.distance, panscon.offflood.250) # select all variables to use; this way, we can use complete.cases and only remove lines with NA RAI
  data.to.use <- data.to.use[complete.cases(data.to.use),] # there is an error in lme if there are NAs, but then if I set na.action = na.omit in the lme model then there is an error in the dredging, so this is the way it has to be
  model.outputs.bushbuck.wet <- lme(RAI ~ poaching + fire.interval + river.distance +
                                           road.major.distance + urema.distance + tree.hansen + 
                                           termite.count.100m + panscon.250m + lion.wet, 
                                       data = data.to.use,
                                       random = ~ 1|StudySite, 
                                       method = "ML",
                                       keep.data = TRUE)
  
  fit.dredge <- dredge(model.outputs.bushbuck.wet, rank = "AIC")
  (attr(fit.dredge, "rank.call"))
  # Get the models (fitted by REML, as in the global model)
  fmList <- get.models(fit.dredge, subset = delta < 2)
  # Because the models originate from 'dredge(..., rank = AICc, REML = FALSE)',
  # the default weights in 'model.avg' are ML based:
  averaged.results.bushbuck.wet <- model.avg(fmList)
  
  estimates <- as.data.frame(averaged.results.bushbuck.wet[[2]])
  
  # take only full estimates, not subset estimates
  estimates <- estimates[1,]
  # move variable names into first column
  estimates <- rbind(Factor = names(estimates), estimates)
  # transpose, keep names
  estimates <- as.data.frame(t(estimates), row.names=F)
  # change names
  names(estimates) <- c("Covariate", "Estimate")
  
  # now wrangle confidence intervals
  confidence.intervals <- confint(averaged.results.bushbuck.wet)
  # move variable names into first column
  row.names.placeholder <- rownames(confidence.intervals)
  rownames(confidence.intervals) <- NULL
  confidence.intervals <- as.data.frame(cbind(row.names.placeholder,confidence.intervals))
  names(confidence.intervals) <- c("Covariate", "LowerCI", "UpperCI")
  averaged.results.bushbuck.wet <- cbind(estimates, confidence.intervals[,2:3])
  averaged.results.bushbuck.wet$CommName <- "Bushbuck"
  
  # and get relative importance values
  importance.values <- as.data.frame(importance(fmList))
  row.names.placeholder <- rownames(importance.values)
  importance.values <- as.data.frame(cbind(row.names.placeholder,importance.values))
  names(importance.values) <- c("Covariate", "Importance")
  averaged.results.bushbuck.wet <- left_join(averaged.results.bushbuck.wet, importance.values)
  
averaged.results.bushbuck.wet$Season <- "wet"

averaged.results.bushbuck.combined.df <- rbind(averaged.results.bushbuck.dry, averaged.results.bushbuck.wet)
#write.csv(averaged.results.bushbuck.combined.df, "Results/RAI/averaged.results.bushbuck.nonstandard.csv", row.names = F)


# now plot results of non-standard model
bushbuck_dry_raster <- 0.461622223 + # intercept
  -0.277391795 * rivers.dist.norm.coarse * 1 +
#  -0.000713924 * termites.crop.100m.norm.coarse * 0.077626625 +
  -0.385015679 * urema.dist.norm.coarse * 1 +
  0.000303678 * roadsmajor.dist.norm.coarse * 0.07701747 +
  0.012930688 * tree.hansen * 0.189485582 +
  -0.020208222 * panscon.250m * 0.185751513 +
  -0.00583516 * lion.dry * 0.100150485 +
  0.298438629348038 * fire.crop.res.norm.coarse * 1 +
  -0.031484461 * poaching.3levels.mask.norm.coarse * 0.33189717

bushbuck_wet_raster <- 0.323372485 +
  -0.106069145 * rivers.dist.norm.coarse * 1 +
  -0.190939545 * urema.dist.norm.coarse * 1 +
  0.000421089 * lion.wet * 0.081688677 +
  -0.054238875 * roadsmajor.dist.norm.coarse * 0.751970296 +
  0.001140283 * tree.hansen * 0.085086687 +
  0.0002812 * poaching.3levels.mask.norm.coarse * 0.081292629 +
  0.029141503 * panscon.250m * 0.307091442 + 
#  -0.00290699 * termites.crop.100m.norm.coarse * 0.109752947 +
  0.129778814 * fire.crop.res.norm.coarse * 1

bushbuck_wet_minus_dry <- bushbuck_wet_raster - bushbuck_dry_raster

#writeRaster(bushbuck_dry_raster, 'bushbuck_dry_raster.tif', format="GTiff", overwrite=TRUE, options=c("INTERLEAVE=BAND","COMPRESS=LZW"))
#writeRaster(bushbuck_wet_raster, 'bushbuck_wet_raster.tif', format="GTiff", overwrite=TRUE, options=c("INTERLEAVE=BAND","COMPRESS=LZW"))
#writeRaster(bushbuck_wet_minus_dry, 'bushbuck_wet_minus_dry.tif', format="GTiff", overwrite=TRUE, options=c("INTERLEAVE=BAND","COMPRESS=LZW"))

```

#### Nyala
```{r nyala manual}
### DRY
  data.to.use <- rai.long.dry[rai.long.dry$SppCode == "TRAN", ]
  data.to.use <- dplyr::select(data.to.use, RAI, StudySite, poaching, poaching.high, fire.interval, road.major.distance, urema.distance, tree.hansen, termite.count.100m, panscon.250m, lion.dry, pan.distance, settlement.distance, river.distance, panscon.offflood.250) # select all variables to use; this way, we can use complete.cases and only remove lines with NA RAI
  data.to.use <- data.to.use[complete.cases(data.to.use),] # there is an error in lme if there are NAs, but then if I set na.action = na.omit in the lme model then there is an error in the dredging, so this is the way it has to be
  model.outputs.nyala.dry <- lme(RAI ~ poaching + fire.interval + river.distance +
                                           road.major.distance + urema.distance + tree.hansen + 
                                           termite.count.100m + panscon.250m + lion.dry, 
                                       data = data.to.use,
                                       random = ~ 1|StudySite, 
                                       method = "ML",
                                       keep.data = TRUE)
  
  fit.dredge <- dredge(model.outputs.nyala.dry, rank = "AIC")
  (attr(fit.dredge, "rank.call"))
  # Get the models (fitted by REML, as in the global model)
  fmList <- get.models(fit.dredge, subset = delta < 2)
  # Because the models originate from 'dredge(..., rank = AICc, REML = FALSE)',
  # the default weights in 'model.avg' are ML based:
  averaged.results.nyala.dry <- model.avg(fmList)
  
  estimates <- as.data.frame(averaged.results.nyala.dry[[2]])
  
  # take only full estimates, not subset estimates
  estimates <- estimates[1,]
  # move variable names into first column
  estimates <- rbind(Factor = names(estimates), estimates)
  # transpose, keep names
  estimates <- as.data.frame(t(estimates), row.names=F)
  # change names
  names(estimates) <- c("Covariate", "Estimate")
  
  # now wrangle confidence intervals
  confidence.intervals <- confint(averaged.results.nyala.dry)
  # move variable names into first column
  row.names.placeholder <- rownames(confidence.intervals)
  rownames(confidence.intervals) <- NULL
  confidence.intervals <- as.data.frame(cbind(row.names.placeholder,confidence.intervals))
  names(confidence.intervals) <- c("Covariate", "LowerCI", "UpperCI")
  averaged.results.nyala.dry <- cbind(estimates, confidence.intervals[,2:3])
  averaged.results.nyala.dry$CommName <- "Nyala"
  
  # and get relative importance values
  importance.values <- as.data.frame(importance(fmList))
  row.names.placeholder <- rownames(importance.values)
  importance.values <- as.data.frame(cbind(row.names.placeholder,importance.values))
  names(importance.values) <- c("Covariate", "Importance")
  averaged.results.nyala.dry <- left_join(averaged.results.nyala.dry, importance.values)
  
averaged.results.nyala.dry$Season <- "dry"

## WET SEASON

  data.to.use <- rai.long.wet[rai.long.wet$SppCode == "TRAN", ]
  data.to.use <- dplyr::select(data.to.use, RAI, StudySite, poaching, poaching.high, fire.interval, road.major.distance, urema.distance, tree.hansen, termite.count.100m, panscon.250m, lion.wet, pan.distance, settlement.distance, river.distance, panscon.offflood.250) # select all variables to use; this way, we can use complete.cases and only remove lines with NA RAI
  data.to.use <- data.to.use[complete.cases(data.to.use),] # there is an error in lme if there are NAs, but then if I set na.action = na.omit in the lme model then there is an error in the dredging, so this is the way it has to be
  model.outputs.nyala.wet <- lme(RAI ~ poaching + fire.interval + river.distance +
                                           road.major.distance + urema.distance + tree.hansen + 
                                           termite.count.100m + panscon.250m + lion.wet, 
                                       data = data.to.use,
                                       random = ~ 1|StudySite, 
                                       method = "ML",
                                       keep.data = TRUE)
  
  fit.dredge <- dredge(model.outputs.nyala.wet, rank = "AIC")
  (attr(fit.dredge, "rank.call"))
  # Get the models (fitted by REML, as in the global model)
  fmList <- get.models(fit.dredge, subset = delta < 2)
  # Because the models originate from 'dredge(..., rank = AICc, REML = FALSE)',
  # the default weights in 'model.avg' are ML based:
  averaged.results.nyala.wet <- model.avg(fmList)
  
  estimates <- as.data.frame(averaged.results.nyala.wet[[2]])
  
  # take only full estimates, not subset estimates
  estimates <- estimates[1,]
  # move variable names into first column
  estimates <- rbind(Factor = names(estimates), estimates)
  # transpose, keep names
  estimates <- as.data.frame(t(estimates), row.names=F)
  # change names
  names(estimates) <- c("Covariate", "Estimate")
  
  # now wrangle confidence intervals
  confidence.intervals <- confint(averaged.results.nyala.wet)
  # move variable names into first column
  row.names.placeholder <- rownames(confidence.intervals)
  rownames(confidence.intervals) <- NULL
  confidence.intervals <- as.data.frame(cbind(row.names.placeholder,confidence.intervals))
  names(confidence.intervals) <- c("Covariate", "LowerCI", "UpperCI")
  averaged.results.nyala.wet <- cbind(estimates, confidence.intervals[,2:3])
  averaged.results.nyala.wet$CommName <- "Nyala"
  
  # and get relative importance values
  importance.values <- as.data.frame(importance(fmList))
  row.names.placeholder <- rownames(importance.values)
  importance.values <- as.data.frame(cbind(row.names.placeholder,importance.values))
  names(importance.values) <- c("Covariate", "Importance")
  averaged.results.nyala.wet <- left_join(averaged.results.nyala.wet, importance.values)
  
averaged.results.nyala.wet$Season <- "wet"

averaged.results.nyala.combined.df <- rbind(averaged.results.nyala.dry, averaged.results.nyala.wet)
#write.csv(averaged.results.nyala.combined.df, "Results/RAI/averaged.results.nyala.nonstandard.csv", row.names = F)

# now plot results of non-standard model
nyala_dry_raster <- 0.080985768 + # intercept
  0.00041179 * rivers.dist.norm.coarse * 0.078060158 +
#  0.035393212 * termites.crop.100m.norm.coarse * 1 +
  0.007187415 * urema.dist.norm.coarse * 0.326171838 +
  -0.000326277 * roadsmajor.dist.norm.coarse * 0.076048091 +
  0.032940402 * tree.hansen * 0.921280338 +
  -0.001353798 * panscon.250m * 0.085933074 +
  0.000392762 * lion.dry * 0.077032371 +
  -0.001954649 * fire.crop.res.norm.coarse * 0.175635376 +
  -0.000156904 * poaching.3levels.mask.norm.coarse * 0.073676922

nyala_wet_raster <- 0.061048365 +
  0.000457357 * rivers.dist.norm.coarse * 0.111988574 +
  0.033507174 * urema.dist.norm.coarse * 1 +
  -0.0000176 * lion.wet * 0.105558897 +
  0.000819886 * roadsmajor.dist.norm.coarse * 0.121658235 +
  0.028856872 * tree.hansen * 1 +
  -0.000467226 * poaching.3levels.mask.norm.coarse * 0.112262471 +
  -0.000401529 * panscon.250m * 0.107019214 + 
#  0.001530096 * termites.crop.100m.norm.coarse * 0.154605789 +
  -0.032250445 * fire.crop.res.norm.coarse * 1

nyala_wet_minus_dry <- nyala_wet_raster - nyala_dry_raster

#writeRaster(nyala_dry_raster, 'nyala_dry_raster.tif', format="GTiff", overwrite=TRUE, options=c("INTERLEAVE=BAND","COMPRESS=LZW"))
#writeRaster(nyala_wet_raster, 'nyala_wet_raster.tif', format="GTiff", overwrite=TRUE, options=c("INTERLEAVE=BAND","COMPRESS=LZW"))
#writeRaster(nyala_wet_minus_dry, 'nyala_wet_minus_dry.tif', format="GTiff", overwrite=TRUE, options=c("INTERLEAVE=BAND","COMPRESS=LZW"))
```

#### Kudu
```{r kudu manual}
### DRY
  data.to.use <- rai.long.dry[rai.long.dry$SppCode == "TRST", ]
  data.to.use <- dplyr::select(data.to.use, RAI, StudySite, poaching, poaching.high, fire.interval, road.major.distance, urema.distance, tree.hansen, termite.count.100m, panscon.250m, lion.dry, pan.distance, settlement.distance, river.distance, panscon.offflood.250) # select all variables to use; this way, we can use complete.cases and only remove lines with NA RAI
  data.to.use <- data.to.use[complete.cases(data.to.use),] # there is an error in lme if there are NAs, but then if I set na.action = na.omit in the lme model then there is an error in the dredging, so this is the way it has to be
  model.outputs.kudu.dry <- lme(RAI ~ poaching + fire.interval + river.distance +
                                           road.major.distance + urema.distance + tree.hansen + 
                                           termite.count.100m + panscon.250m + lion.dry, 
                                       data = data.to.use,
                                       random = ~ 1|StudySite, 
                                       method = "ML",
                                       keep.data = TRUE)
  
  fit.dredge <- dredge(model.outputs.kudu.dry, rank = "AIC")
  (attr(fit.dredge, "rank.call"))
  # Get the models (fitted by REML, as in the global model)
  fmList <- get.models(fit.dredge, subset = delta < 2)
  # Because the models originate from 'dredge(..., rank = AICc, REML = FALSE)',
  # the default weights in 'model.avg' are ML based:
  averaged.results.kudu.dry <- model.avg(fmList)
  
  estimates <- as.data.frame(averaged.results.kudu.dry[[2]])
  
  # take only full estimates, not subset estimates
  estimates <- estimates[1,]
  # move variable names into first column
  estimates <- rbind(Factor = names(estimates), estimates)
  # transpose, keep names
  estimates <- as.data.frame(t(estimates), row.names=F)
  # change names
  names(estimates) <- c("Covariate", "Estimate")
  
  # now wrangle confidence intervals
  confidence.intervals <- confint(averaged.results.kudu.dry)
  # move variable names into first column
  row.names.placeholder <- rownames(confidence.intervals)
  rownames(confidence.intervals) <- NULL
  confidence.intervals <- as.data.frame(cbind(row.names.placeholder,confidence.intervals))
  names(confidence.intervals) <- c("Covariate", "LowerCI", "UpperCI")
  averaged.results.kudu.dry <- cbind(estimates, confidence.intervals[,2:3])
  averaged.results.kudu.dry$CommName <- "Kudu"
  
  # and get relative importance values
  importance.values <- as.data.frame(importance(fmList))
  row.names.placeholder <- rownames(importance.values)
  importance.values <- as.data.frame(cbind(row.names.placeholder,importance.values))
  names(importance.values) <- c("Covariate", "Importance")
  averaged.results.kudu.dry <- left_join(averaged.results.kudu.dry, importance.values)
  
averaged.results.kudu.dry$Season <- "dry"

## WET SEASON

  data.to.use <- rai.long.wet[rai.long.wet$SppCode == "TRST", ]
  data.to.use <- dplyr::select(data.to.use, RAI, StudySite, poaching, poaching.high, fire.interval, road.major.distance, urema.distance, tree.hansen, termite.count.100m, panscon.250m, lion.wet, pan.distance, settlement.distance, river.distance, panscon.offflood.250) # select all variables to use; this way, we can use complete.cases and only remove lines with NA RAI
  data.to.use <- data.to.use[complete.cases(data.to.use),] # there is an error in lme if there are NAs, but then if I set na.action = na.omit in the lme model then there is an error in the dredging, so this is the way it has to be
  model.outputs.kudu.wet <- lme(RAI ~ poaching + fire.interval + river.distance +
                                           road.major.distance + urema.distance + tree.hansen + 
                                           termite.count.100m + panscon.250m + lion.wet, 
                                       data = data.to.use,
                                       random = ~ 1|StudySite, 
                                       method = "ML",
                                       keep.data = TRUE)
  
  fit.dredge <- dredge(model.outputs.kudu.wet, rank = "AIC")
  (attr(fit.dredge, "rank.call"))
  # Get the models (fitted by REML, as in the global model)
  fmList <- get.models(fit.dredge, subset = delta < 2)
  # Because the models originate from 'dredge(..., rank = AICc, REML = FALSE)',
  # the default weights in 'model.avg' are ML based:
  averaged.results.kudu.wet <- model.avg(fmList)
  
  estimates <- as.data.frame(averaged.results.kudu.wet[[2]])
  
  # take only full estimates, not subset estimates
  estimates <- estimates[1,]
  # move variable names into first column
  estimates <- rbind(Factor = names(estimates), estimates)
  # transpose, keep names
  estimates <- as.data.frame(t(estimates), row.names=F)
  # change names
  names(estimates) <- c("Covariate", "Estimate")
  
  # now wrangle confidence intervals
  confidence.intervals <- confint(averaged.results.kudu.wet)
  # move variable names into first column
  row.names.placeholder <- rownames(confidence.intervals)
  rownames(confidence.intervals) <- NULL
  confidence.intervals <- as.data.frame(cbind(row.names.placeholder,confidence.intervals))
  names(confidence.intervals) <- c("Covariate", "LowerCI", "UpperCI")
  averaged.results.kudu.wet <- cbind(estimates, confidence.intervals[,2:3])
  averaged.results.kudu.wet$CommName <- "Kudu"
  
  # and get relative importance values
  importance.values <- as.data.frame(importance(fmList))
  row.names.placeholder <- rownames(importance.values)
  importance.values <- as.data.frame(cbind(row.names.placeholder,importance.values))
  names(importance.values) <- c("Covariate", "Importance")
  averaged.results.kudu.wet <- left_join(averaged.results.kudu.wet, importance.values)
  
averaged.results.kudu.wet$Season <- "wet"

averaged.results.kudu.combined.df <- rbind(averaged.results.kudu.dry, averaged.results.kudu.wet)
#write.csv(averaged.results.kudu.combined.df, "Results/RAI/averaged.results.kudu.nonstandard.csv", row.names = F)

# now plot results of non-standard model
kudu_dry_raster <- 0.028727517 + # intercept
  0.0000854297160324408 * rivers.dist.norm.coarse * 0.062948452 +
#  0.0000525742367459995 * termites.crop.100m.norm.coarse * 0.060892203 +
  0.0000669543284017135 * urema.dist.norm.coarse * 0.061488203 +
  -0.0000294877590165378 * roadsmajor.dist.norm.coarse * 0.059707164 +
  -0.00110289 * tree.hansen * 0.246121295 +
  -0.001437951 * panscon.250m * 0.218392295 +
  -0.0000226926146403405 * lion.dry * 0.059596092 +
  0.010977805 * fire.crop.res.norm.coarse * 1 +
  -0.001476212 * poaching.3levels.mask.norm.coarse * 0.281534244

kudu_wet_raster <- 0.020065035 +
  0.000427329 * rivers.dist.norm.coarse * 0.101953446 +
  0.000116114 * urema.dist.norm.coarse * 0.076175889 +
  -0.00014118 * lion.wet * 0.077781278 +
  0.000244811 * roadsmajor.dist.norm.coarse * 0.084590848 +
  -0.0000906161895928215 * tree.hansen * 0.074654572 +
  0.000210027 * poaching.3levels.mask.norm.coarse * 0.082759256 +
  -0.000906382 * panscon.250m * 0.107285312 + 
#  0.000217764 * termites.crop.100m.norm.coarse * 0.083558573 +
  0.000563616 * fire.crop.res.norm.coarse * 0.113406065

kudu_wet_minus_dry <- kudu_wet_raster - kudu_dry_raster

#writeRaster(kudu_dry_raster, 'kudu_dry_raster.tif', format="GTiff", overwrite=TRUE, options=c("INTERLEAVE=BAND","COMPRESS=LZW"))
#writeRaster(kudu_wet_raster, 'kudu_wet_raster.tif', format="GTiff", overwrite=TRUE, options=c("INTERLEAVE=BAND","COMPRESS=LZW"))
#writeRaster(kudu_wet_minus_dry, 'kudu_wet_minus_dry.tif', format="GTiff", overwrite=TRUE, options=c("INTERLEAVE=BAND","COMPRESS=LZW"))
```




## Raster stack projection troubleshooting - ignore this, just here for the record

Run a test model (impala in dry season). Here, using only spatial covariates (the ones that had come out in the top model, but before using normalized variables), and ignoring covariates that were recorded at the camera site (ex. number of large termite mounds, dominant tree).
```{r raster stack troubleshoot, eval = F}
aeme.dry.spatial <- glm(RAI.dry ~ poaching.high + road.major.distance + tree.250m + pans.250m, data = rai.aeme)

prediction <- raster::predict(raster.stack, aeme.dry.spatial, type = "response") # to predict the response variable from object "mymodel"
plot(prediction)
```
There are some weird white areas where the model doesn't seem to be predicting, when it should be predicting to the entire extent of the raster stack. Maybe an issue of the color ramp chosen?

Nope, because this doesn't solve the problem.
```{rraster stack troubleshoot 2, eval = F}
library(RColorBrewer)
my.palette <- brewer.pal(n = 9, name = "OrRd")
plot(prediction, col = my.palette)
```

Try one variable at a time. This doesn't work; they all still have the same weird shape, which suggests something wrong with the raster stack.
```{r test raster stack issue, eval = F}
aeme.dry.spatial2 <- glm(RAI.dry ~ poaching.high, data = rai.aeme)
prediction2 <- raster::predict(raster.stack, aeme.dry.spatial2, type = "response") # to predict the response variable from object "mymodel"
plot(prediction2, col = my.palette, main = "poaching.high")

aeme.dry.spatial3 <- glm(RAI.dry ~ road.major.distance, data = rai.aeme)
prediction3 <- raster::predict(raster.stack, aeme.dry.spatial3, type = "response") # to predict the response variable from object "mymodel"
plot(prediction3, col = my.palette, main = "road.major.distance")

aeme.dry.spatial4 <- glm(RAI.dry ~ tree.250m, data = rai.aeme)
prediction4 <- raster::predict(raster.stack, aeme.dry.spatial4, type = "response") # to predict the response variable from object "mymodel"
plot(prediction4, col = my.palette, main = "tree.250m")

aeme.dry.spatial5 <- glm(RAI.dry ~ pans.250m, data = rai.aeme)
prediction5 <- raster::predict(raster.stack, aeme.dry.spatial5, type = "response") # to predict the response variable from object "mymodel"
plot(prediction5, col = my.palette, main = "pans.250m")
```

Plot each of the raw layers of the raster stack. Interestingly, when I plot the boundary distance either from within the raster stack or on its own, there are NOT any weird gaps.
```{r plot raster stack raw, eval = F}
for (i in 1:26) {
  plot(raster.stack[[i]], main = names(raster.stack[[i]]))
}
```
Okay, found the problem: it's the fire date layers, which are NA for days that didn't burn. Going to pull them from raster stack above.

